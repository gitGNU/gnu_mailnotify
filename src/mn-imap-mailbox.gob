/* 
 * mn-imap-mailbox.gob - IMAP 4rev1 support for Mail Notification
 * Complies with RFC 3501
 *
 * Copyright (c) 2004 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

requires 2.0.10

%headertop{
#include "mn-authenticated-mailbox.h"
%}
%{
#include "config.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <glib/gi18n.h>
#include <libgnomevfs/gnome-vfs-utils.h>
#include <eel/eel.h>
#include "mn-mailbox-private.h"
#include "mn-util.h"
#include "mn-client-session.h"
#ifdef WITH_MIME
#include "mn-message-mime.h"
#endif

#define HAS_CURRENT_TAG(response, priv)	(! strcmp((response)->tag, (priv)->tag))
#define IS(response, token)		(! strcmp((response)->response, (token)))
#define IS_OK(response)			IS(response, "OK")
#define IS_NO(response)			IS(response, "NO")
#define IS_BAD(response)		IS(response, "BAD")
#define IS_BYE(response)		IS(response, "BYE")

  enum
  {
    STATE_GREETING = MN_CLIENT_SESSION_INITIAL_STATE,
    STATE_CAPABILITY,
#ifdef WITH_SSL
    STATE_STARTTLS,
#endif
#ifdef WITH_SASL
    STATE_AUTHENTICATE,
#endif
    STATE_LOGIN,
#ifdef WITH_MIME
    STATE_EXAMINE,
    STATE_SEARCH,
    STATE_FETCH,
#else /* WITH_MIME */
    STATE_STATUS,
#endif
    STATE_LOGOUT
  };
  
  enum
  {
    RESULT_ERROR_LOGOUT		= -1, /* server reported an error, logout normally */
    RESULT_ERROR_END		= -2, /* server reported an error, close the connection */
    RESULT_DEFAULT_HANDLER	= -3  /* invoke the default response handler */
  };

  struct _MNClientSessionPrivate
  {
    MNMailbox		*mailbox;
    MNIMAPMailbox	*self;
    MNClientSession	*session;
    int			numeric_tag;
    char		tag[5];
    char		**capabilities;
    GSList		*auth_mechanisms;
    gboolean		authentication_failed;
#ifdef WITH_MIME
    gboolean		search_received;
    GSList		*fetch_numbers;
    char		*fetch_set;
    GSList		*received_numbers;
    GSList		*messages;
#else /* WITH_MIME */
    gboolean		status_received;
#endif
#ifdef WITH_SSL
    gboolean		starttls_completed;
#endif
#ifdef WITH_SASL
    const char		*sasl_mechanism;
#endif
  };
  
  struct _MNClientSessionResponse
  {
    char		*continuation;
    char		*tag;
    char		*response;
    char		*code;
    char		*arguments;
  };
%}

class MN:IMAP:Mailbox from MN:Authenticated:Mailbox
{
  class_init (class)
  {
    MN_MAILBOX_CLASS(class)->format = "IMAP";
  }

  override (G:Object) GObject *
    constructor (GType type, guint n_construct_properties, GObjectConstructParam *construct_params)
  {
    GObject *object;
    MNMailbox *mailbox;

    object = PARENT_HANDLER(type, n_construct_properties, construct_params);
    mailbox = MN_MAILBOX(object);

#ifndef WITH_SSL
    if (MN_URI_IS_SSL(mailbox->uri) || MN_URI_IS_INBAND_SSL(mailbox->uri))
      mn_mailbox_set_init_error(mailbox, _("SSL/TLS support has not been compiled in"));
#endif /* WITH_SSL */

    return object;
  }

  override (MN:Mailbox) gboolean
    impl_is (MNMailbox *dummy, MN:URI *uri (check null type))
  {
    return MN_URI_IS_IMAP(uri);
  }

  private int
    handle_greeting_cb (MNClientSession *session (check null),
			MNClientSessionResponse *response (check null),
			MNClientSessionPrivate *priv (check null))
  {
    priv->session = session;

    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (! response->tag && IS_OK(response))
      {
	if (response->code)
	  {
	    if (! strcmp(response->code, "CAPABILITY"))
	      self_session_parse_capabilities(priv, NULL);
	    else if (g_str_has_prefix(response->code, "CAPABILITY "))
	      self_session_parse_capabilities(priv, response->code + 11);
	  }
	
	return priv->capabilities
	  ? self_session_after_capability(priv)
	  : STATE_CAPABILITY;
      }
    else if (! response->tag && IS(response, "PREAUTH"))
      return self_session_check_mail(priv);
    else if (! response->tag && IS_BYE(response))
      return RESULT_ERROR_END;
    else
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
  }

  private int
    enter_capability_cb (MNClientSession *session (check null),
			 MNClientSessionPrivate *priv (check null))
  {
    g_strfreev(priv->capabilities);
    priv->capabilities = NULL;

    eel_g_slist_free_deep(priv->auth_mechanisms);
    priv->auth_mechanisms = NULL;

    return self_session_write(priv, "CAPABILITY");
  }

  private int
    handle_capability_cb (MNClientSession *session (check null),
			  MNClientSessionResponse *response (check null),
			  MNClientSessionPrivate *priv (check null))
  {
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      {
		return priv->capabilities
		  ? self_session_after_capability(priv)
		  : mn_client_session_error(session, _("server did not send capabilities"));
	      }
	    else if (IS_BAD(response))
	      return RESULT_ERROR_LOGOUT;
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }
    else if (IS(response, "CAPABILITY"))
      {
	self_session_parse_capabilities(priv, response->arguments);
	return MN_CLIENT_SESSION_RESULT_CONTINUE;
      }
    
    return RESULT_DEFAULT_HANDLER;
  }
  
  private int
    enter_starttls_cb (MNClientSession *session (check null),
		       MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_SSL
    return self_session_write(priv, "STARTTLS");
#else
    g_return_val_if_reached(0);
#endif /* WITH_SSL */
  }
  
  private int
    handle_starttls_cb (MNClientSession *session (check null),
			MNClientSessionResponse *response (check null),
			MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_SSL
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      {
		priv->starttls_completed = TRUE;
		return mn_client_session_enable_ssl(session)
		  ? STATE_CAPABILITY
		  : RESULT_ERROR_END;
	      }
	    else if (IS_BAD(response))
	      return self_session_authenticate(priv);
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }

    return RESULT_DEFAULT_HANDLER;
#else
    g_return_val_if_reached(0);
#endif /* WITH_SSL */
  }
  
  private int
    enter_authenticate_cb (MNClientSession *session (check null),
			   MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_SASL
    if (mn_client_session_sasl_authentication_start(priv->session,
						    "imap",
						    priv->auth_mechanisms,
						    priv->mailbox->uri->authmech,
						    &priv->sasl_mechanism))
      return self_session_write(priv, "AUTHENTICATE %s", priv->sasl_mechanism);
    else
      return self_session_authenticate_fallback(priv);
#else
    g_return_val_if_reached(0);
#endif /* WITH_SASL */
  }
  
  private int
    handle_authenticate_cb (MNClientSession *session (check null),
			    MNClientSessionResponse *response (check null),
			    MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_SASL
    if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      {
		return mn_client_session_sasl_authentication_done(session)
		  ? self_session_check_mail(priv)
		  : MN_CLIENT_SESSION_RESULT_END;
	      }
	    else if (IS_NO(response) || IS_BAD(response))
	      return self_session_authenticate_fallback(priv);
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }
    else if (response->continuation)
      return mn_client_session_sasl_authentication_step(session, response->continuation);
    
    return RESULT_DEFAULT_HANDLER;
#else
    g_return_val_if_reached(0);
#endif /* WITH_SASL */
  }
  
  private int
    enter_login_cb (MNClientSession *session (check null),
		    MNClientSessionPrivate *priv (check null))
  {
    if (self_session_has_capability(priv, "LOGINDISABLED"))
      {
	mn_client_session_notice(session, _("server advertised LOGINDISABLED, not using LOGIN authentication"));
	mn_client_session_error(session, _("unable to login"));
	return STATE_LOGOUT;
      }
    else
      {
	char *quoted_username;
	char *quoted_password;
	int result;

	quoted_username = self_quote(priv->mailbox->uri->username);
	quoted_password = self_quote(MN_AUTHENTICATED_MAILBOX(priv->self)->password);
	result = self_session_write(priv, "LOGIN %s %s", quoted_username, quoted_password);
	g_free(quoted_username);
	g_free(quoted_password);

	return result;
      }
  }
  
  private int
    handle_login_cb (MNClientSession *session (check null),
		     MNClientSessionResponse *response (check null),
		     MNClientSessionPrivate *priv (check null))
  {
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      return self_session_check_mail(priv);
	    else if (IS_NO(response) || IS_BAD(response))
	      {
		priv->authentication_failed = TRUE;
		return RESULT_ERROR_LOGOUT;
	      }
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }
    
    return RESULT_DEFAULT_HANDLER;
  }
  
  private int
    enter_examine_cb (MNClientSession *session (check null),
		      MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_MIME
    char *quoted_mailbox;
    int result;

    quoted_mailbox = self_quote(priv->mailbox->uri->path);
    result = self_session_write(priv, "EXAMINE %s", quoted_mailbox);
    g_free(quoted_mailbox);

    return result;
#else /* WITH_MIME */
    g_return_val_if_reached(0);
#endif
  }
  
  private int
    handle_examine_cb (MNClientSession *session (check null),
		       MNClientSessionResponse *response (check null),
		       MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_MIME
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      return STATE_SEARCH;
	    else if (IS_NO(response) || IS_BAD(response))
	      return RESULT_ERROR_LOGOUT;
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }

    return RESULT_DEFAULT_HANDLER;
#else /* WITH_MIME */
    g_return_val_if_reached(0);
#endif
  }
  
  private int
    enter_search_cb (MNClientSession *session (check null),
		     MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_MIME
    return self_session_write(priv, "SEARCH UNSEEN");
#else
    g_return_val_if_reached(0);
#endif
  }
  
  private int
    handle_search_cb (MNClientSession *session (check null),
		      MNClientSessionResponse *response (check null),
		      MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_MIME
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      {
		if (priv->search_received)
		  {
		    if (priv->fetch_set)
		      return STATE_FETCH;
		    else
		      {
			GDK_THREADS_ENTER();
			mn_mailbox_set_has_new(priv->mailbox, FALSE);
			mn_mailbox_set_messages(priv->mailbox, NULL);
			gdk_flush();
			GDK_THREADS_LEAVE();

			return STATE_LOGOUT;
		      }
		  }
		else		/* compliance error */
		  return mn_client_session_error(session, _("server did not send search results"));
	      }
	    else if (IS_NO(response) || IS_BAD(response))
	      return RESULT_ERROR_LOGOUT;
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }
    else if (IS(response, "SEARCH"))
      {
	if (response->arguments)
	  {
	    char **numbers;
	    GString *string;
	    int i;

	    numbers = g_strsplit(response->arguments, " ", 0);
	    string = g_string_new(NULL);

	    for (i = 0; numbers[i]; i++)
	      if (mn_str_isnumeric(numbers[i]))
		{
		  int n = atoi(numbers[i]);

		  if (*string->str)
		    g_string_append_c(string, ',');
		  g_string_append(string, numbers[i]);

		  priv->fetch_numbers = g_slist_append(priv->fetch_numbers, GINT_TO_POINTER(n));
		}

	    g_strfreev(numbers);
	    priv->fetch_set = g_string_free(string, FALSE);
	  }

	priv->search_received = TRUE;
	return MN_CLIENT_SESSION_RESULT_CONTINUE;
      }

    return RESULT_DEFAULT_HANDLER;
#else /* WITH_MIME */
    g_return_val_if_reached(0);
#endif
  }
  
  private int
    enter_fetch_cb (MNClientSession *session (check null),
		    MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_MIME
    g_return_val_if_fail(priv->fetch_set != NULL, 0);
    return self_session_write(priv, "FETCH %s BODY[HEADER]", priv->fetch_set);
#else /* WITH_MIME */
    g_return_val_if_reached(0);
#endif
  }
  
  private int
    handle_fetch_cb (MNClientSession *session (check null),
		     MNClientSessionResponse *response (check null),
		     MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_MIME
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      {
		GSList *l;

		MN_LIST_FOREACH(l, priv->fetch_numbers)
		  if (! g_slist_find(priv->received_numbers, l->data))
		    /* compliance error */
		    return mn_client_session_error(session, _("server did not send all the messages we requested"));
		    
		GDK_THREADS_ENTER();
		mn_mailbox_set_has_new(priv->mailbox, priv->messages != NULL);
		mn_mailbox_set_messages(priv->mailbox, priv->messages);
		gdk_flush();
		GDK_THREADS_LEAVE();
		
		return STATE_LOGOUT;
	      }
	    else if (IS_NO(response) || IS_BAD(response))
	      return RESULT_ERROR_LOGOUT;
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }
    else if (mn_str_isnumeric(response->response)
	     && response->arguments
	     && g_str_has_prefix(response->arguments, "FETCH (BODY[HEADER]"))
      {
	int n = atoi(response->response);

	if (g_slist_find(priv->fetch_numbers, GINT_TO_POINTER(n)))
	  {
	    char *p;
	    int len;

	    priv->received_numbers = g_slist_append(priv->received_numbers, GINT_TO_POINTER(n));

	    /* we assume the header string will be in literal form */

	    p = strrchr(response->arguments, '{');
	    if (p && sscanf(p, "{%d}", &len) == 1 && len >= 0)
	      {
		gconstpointer buf;
		
		buf = mn_client_session_read(session, len);
		if (! buf)
		  return MN_CLIENT_SESSION_RESULT_END;
		
		priv->messages = g_slist_append(priv->messages, mn_message_new_from_buffer(priv->mailbox->uri, buf, len));
		
		/* read end of line (after literal) */
		if (! mn_client_session_read_line(session))
		  return MN_CLIENT_SESSION_RESULT_END;
	      }
	    else
	      priv->messages = g_slist_append(priv->messages, mn_message_new_from_error(priv->mailbox->uri, _("unable to fetch message")));

	    return MN_CLIENT_SESSION_RESULT_CONTINUE;
	  }
      }
	
    return RESULT_DEFAULT_HANDLER;
#else /* WITH_MIME */
    g_return_val_if_reached(0);
#endif
  }
  
  private int
    enter_status_cb (MNClientSession *session (check null),
		     MNClientSessionPrivate *priv (check null))
  {
#ifndef WITH_MIME
    char *quoted_mailbox;
    int result;

    quoted_mailbox = self_quote(priv->mailbox->uri->path);
    result = self_session_write(priv, "STATUS %s (UNSEEN)", quoted_mailbox);
    g_free(quoted_mailbox);

    return result;
#else /* ! WITH_MIME */
    g_return_val_if_reached(0);
#endif
  }
  
  private int
    handle_status_cb (MNClientSession *session (check null),
		      MNClientSessionResponse *response (check null),
		      MNClientSessionPrivate *priv (check null))
  {
#ifndef WITH_MIME
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag)
      {
	if (HAS_CURRENT_TAG(response, priv))
	  {
	    if (IS_OK(response))
	      {
		if (priv->status_received)
		  return STATE_LOGOUT;
		else		/* compliance error */
		  return mn_client_session_error(session, _("server did not send status"));
	      }
	    else if (IS_NO(response) || IS_BAD(response))
	      return RESULT_ERROR_LOGOUT;
	    else
	      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
	  }
      }
    else if (IS(response, "STATUS"))
      {
	int count;
	
	if (response->arguments && sscanf(response->arguments, "%*s (UNSEEN %i)", &count) == 1)
	  {
	    priv->status_received = TRUE;
	    
	    GDK_THREADS_ENTER();
	    mn_mailbox_set_has_new(priv->mailbox, count != 0);
	    gdk_flush();
	    GDK_THREADS_LEAVE();
	    
	    return MN_CLIENT_SESSION_RESULT_CONTINUE;
	  }
	else
	  return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
      }
    
    return RESULT_DEFAULT_HANDLER;
#else /* ! WITH_MIME */
    g_return_val_if_reached(0);
#endif
  }

  private int
    enter_logout_cb (MNClientSession *session (check null),
		     MNClientSessionPrivate *priv (check null))
  {
    return self_session_write(priv, "LOGOUT");
  }

  private int
    handle_logout_cb (MNClientSession *session (check null),
		      MNClientSessionResponse *response (check null),
		      MNClientSessionPrivate *priv (check null))
  {
    if (response->continuation)
      return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
    else if (response->tag && HAS_CURRENT_TAG(response, priv))
      {
	if (IS_OK(response))
	  return MN_CLIENT_SESSION_RESULT_END;
	else if (IS_BAD(response))
	  return RESULT_ERROR_END;
	else
	  return MN_CLIENT_SESSION_RESULT_BAD_RESPONSE_FOR_CONTEXT;
      }
    else
      return MN_CLIENT_SESSION_RESULT_CONTINUE;
  }
  
  override (MN:Authenticated:Mailbox) MNAuthenticatedMailboxResult
    impl_authenticated_check (MN:Authenticated:Mailbox *authenticated_mailbox (check null type),
			      GError **err)
  {
    MNMailbox *mailbox = MN_MAILBOX(authenticated_mailbox);
    Self *self = SELF(authenticated_mailbox);
    MNClientSessionState states[] = {
      { STATE_GREETING,		NULL,				self_handle_greeting_cb },
      { STATE_CAPABILITY,	self_enter_capability_cb,	self_handle_capability_cb },
#ifdef WITH_SSL
      { STATE_STARTTLS,		self_enter_starttls_cb,		self_handle_starttls_cb },
#endif
#ifdef WITH_SASL
      { STATE_AUTHENTICATE,	self_enter_authenticate_cb,	self_handle_authenticate_cb },
#endif
      { STATE_LOGIN,		self_enter_login_cb,		self_handle_login_cb },
#ifdef WITH_MIME
      { STATE_EXAMINE,		self_enter_examine_cb,		self_handle_examine_cb },
      { STATE_SEARCH,		self_enter_search_cb,		self_handle_search_cb },
      { STATE_FETCH,		self_enter_fetch_cb,		self_handle_fetch_cb },
#else /* WITH_MIME */
      { STATE_STATUS,		self_enter_status_cb,		self_handle_status_cb },
#endif
      { STATE_LOGOUT,		self_enter_logout_cb,		self_handle_logout_cb },
      
      MN_CLIENT_SESSION_STATES_END
    };
    MNClientSessionCallbacks callbacks = {
      self_notice_cb,
      self_response_new_cb,
      self_response_free_cb,
      self_custom_handler_cb
    };
    MNClientSessionPrivate priv;
    gboolean status;

    memset(&priv, 0, sizeof(priv));
    priv.mailbox = mailbox;
    priv.self = self;
    
    status = mn_client_session_run(states,
				   &callbacks,
#ifdef WITH_SSL
				   MN_URI_IS_SSL(mailbox->uri),
#endif
				   mailbox->uri->hostname,
				   mailbox->uri->port,
				   mailbox->uri->username,
				   MN_AUTHENTICATED_MAILBOX(self)->password,
				   &priv,
				   err);
    
    g_strfreev(priv.capabilities);
    eel_g_slist_free_deep(priv.auth_mechanisms);

#ifdef WITH_MIME
    g_slist_free(priv.fetch_numbers);
    g_free(priv.fetch_set);
    g_slist_free(priv.received_numbers);
    mn_g_object_slist_free(priv.messages);
#endif

    return status
      ? MN_AUTHENTICATED_MAILBOX_OK
      : (priv.authentication_failed
	 ? MN_AUTHENTICATED_MAILBOX_ERROR_AUTHENTICATION
	 : MN_AUTHENTICATED_MAILBOX_ERROR_OTHER);
  }
  
  private void
    notice_cb (MNClientSession *session (check null),
	       const char *str (check null),
	       MNClientSessionPrivate *priv (check null))
  {
    mn_mailbox_notice(priv->mailbox, "%s", str);
  }
  
  private MNClientSessionResponse *
    response_new_cb (MNClientSession *session (check null),
		     const char *input (check null),
		     MNClientSessionPrivate *priv (check null))
  {
    MNClientSessionResponse *response = NULL;

    if (g_str_has_prefix(input, "+ "))
      {
	response = g_new0(MNClientSessionResponse, 1);
	response->continuation = g_strdup(input + 2);
      }
    else
      {
	char **tokens;
	
	tokens = g_strsplit(input, " ", 3);
	if (tokens[0] && tokens[1])
	  {
	    if (tokens[2] && tokens[2][0] == '[')
	      {
		char *code_start;
		char *code_end;
		
		code_start = tokens[2] + 1;
		code_end = strchr(code_start, ']');
		if (code_end)
		  {
		    response = g_new0(MNClientSessionResponse, 1);
		    response->code = g_strndup(code_start, code_end - code_start);
		    response->arguments = code_end[1] ? g_strdup(code_end + 2) : NULL;
		  }
	      }
	    else
	      {
		response = g_new0(MNClientSessionResponse, 1);
		response->arguments = g_strdup(tokens[2]);
	      }
	    
	    if (response)
	      {
		response->tag = ! strcmp(tokens[0], "*") ? NULL : g_strdup(tokens[0]);
		response->response = g_strdup(tokens[1]);
	      }
	  }
	g_strfreev(tokens);
      }
    
    return response;
  }

  private void
    response_free_cb (MNClientSession *session (check null),
		      MNClientSessionResponse *response (check null),
		      MNClientSessionPrivate *priv (check null))
  {
    g_free(response->continuation);
    g_free(response->tag);
    g_free(response->response);
    g_free(response->code);
    g_free(response->arguments);
    g_free(response);
  }
  
  private int
    custom_handler_cb (MNClientSession *session (check null),
		       MNClientSessionResponse *response (check null),
		       int result,
		       MNClientSessionPrivate *priv (check null))
  {
    switch (result)
      {
      case RESULT_ERROR_LOGOUT:
	self_session_set_error_from_arguments(priv, response);
	return STATE_LOGOUT;

      case RESULT_ERROR_END:
	self_session_set_error_from_arguments(priv, response);
	return MN_CLIENT_SESSION_RESULT_END;

      case RESULT_DEFAULT_HANDLER:
	if (! response->tag && IS_BYE(response))
	  return RESULT_ERROR_END;
	else
	  return MN_CLIENT_SESSION_RESULT_CONTINUE;
	
      default:
	g_return_val_if_reached(0);
      }
  }

  private void
    session_set_error_from_arguments (MNClientSessionPrivate *priv (check null),
				      MNClientSessionResponse *response (check null))
  {
    if (response->arguments)
      mn_client_session_error(priv->session, "\"%s\"", response->arguments);
    else
      mn_client_session_error(priv->session, _("unknown server error"));
  }

  private int
    session_write (MNClientSessionPrivate *priv (check null),
		   const char *format (check null),
		   ...)
  {
    va_list args;
    char *command;
    int result;

    va_start(args, format);
    command = g_strdup_vprintf(format, args);
    va_end(args);
    
    if (priv->numeric_tag == 1000)
      priv->numeric_tag = 0;
    sprintf(priv->tag, "a%03i", priv->numeric_tag++);

    result = mn_client_session_write(priv->session, "%s %s", priv->tag, command);
    g_free(command);

    return result;
  }

  private void
    session_parse_capabilities (MNClientSessionPrivate *priv (check null),
				const char *capabilities)
  {
    if (capabilities)
      {
	int i;
	
	priv->capabilities = g_strsplit(capabilities, " ", 0);
	
	for (i = 0; priv->capabilities[i]; i++)
	  if (g_str_has_prefix(priv->capabilities[i], "AUTH="))
	    priv->auth_mechanisms = g_slist_append(priv->auth_mechanisms, g_strdup(priv->capabilities[i] + 5));
      }
    else
      priv->capabilities = g_new0(char *, 1);
  }

  private gboolean
    session_has_capability (MNClientSessionPrivate *priv (check null),
			    const char *capability (check null))
  {
    int i;

    g_return_val_if_fail(priv->capabilities != NULL, FALSE);

    for (i = 0; priv->capabilities[i]; i++)
      if (! strcmp(priv->capabilities[i], capability))
	return TRUE;
    
    return FALSE;
  }
  
  private int
    session_after_capability (MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_SSL
    if (MN_URI_IS_INBAND_SSL(priv->mailbox->uri)
	&& ! MN_URI_IS_SSL(priv->mailbox->uri)
	&& ! priv->starttls_completed)
      {
	if (self_session_has_capability(priv, "STARTTLS"))
	  return STATE_STARTTLS;
	else
	  {
	    mn_client_session_error(priv->session, _("server does not support in-band SSL/TLS"));
	    return STATE_LOGOUT;
	  }
      }
    else
#endif /* WITH_SSL */
      return self_session_authenticate(priv);
  }
  
  private int
    session_authenticate (MNClientSessionPrivate *priv (check null))
  {
    if (priv->mailbox->uri->authmech)
      {
	if (*priv->mailbox->uri->authmech != '+')
	  {
#ifdef WITH_SASL
	    return STATE_AUTHENTICATE;
#else
	    return mn_client_session_error(priv->session, _("a SASL authentication mechanism was selected but SASL support has not been compiled in"));
#endif /* WITH_SASL */
	  }
	else
	  {
	    if (! strcmp(priv->mailbox->uri->authmech, "+LOGIN"))
	      return STATE_LOGIN;
	    else
	      return mn_client_session_error(priv->session, _("unknown authentication mechanism \"%s\""), priv->mailbox->uri->authmech);
	  }
      }
    else
      {
#ifdef WITH_SASL
	if (priv->auth_mechanisms)
	  return STATE_AUTHENTICATE;
#endif /* WITH_SASL */
	return STATE_LOGIN;
      }
  }

  private int
    session_authenticate_fallback (MNClientSessionPrivate *priv (check null))
  {
    if (! priv->mailbox->uri->authmech)
      {
	mn_client_session_notice(priv->session, _("falling back to IMAP LOGIN authentication"));
	return STATE_LOGIN;
      }

    priv->authentication_failed = TRUE;
    return mn_client_session_error(priv->session, _("authentication failed"));
  }

  private int
    session_check_mail (MNClientSessionPrivate *priv (check null))
  {
#ifdef WITH_MIME
    return STATE_EXAMINE;
#else
    return STATE_STATUS;
#endif
  }

  /**
   * quote:
   * @str: the string to quote
   *
   * Quotes a string using RFC 3501 BNF rules.
   *
   * Return value: the quoted string.
   **/
  private char *
    quote (const char *str (check null))
  {
    GString *quoted;
    int i;

    quoted = g_string_new("\"");
    for (i = 0; str[i]; i++)
      if (str[i] == '"' || str[i] == '\\') /* quoted-specials in BNF */
	g_string_append_printf(quoted, "\\%c", str[i]);
      else
	g_string_append_c(quoted, str[i]);
    g_string_append_c(quoted, '"');

    return g_string_free(quoted, FALSE);
  }
}
