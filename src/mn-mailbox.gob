/* 
 * Copyright (c) 2003, 2004 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

requires 2.0.10

%headertop{
#include "config.h"
#include <stdarg.h>
#include "mn-message.h"
#include "mn-uri.h"
%}

%privateheader{
#include <libgnomevfs/gnome-vfs.h>

  typedef enum
  {
    MN_MAILBOX_MONITOR_EVENT_CHANGED		= 1 << GNOME_VFS_MONITOR_EVENT_CHANGED,
    MN_MAILBOX_MONITOR_EVENT_DELETED		= 1 << GNOME_VFS_MONITOR_EVENT_DELETED,
    MN_MAILBOX_MONITOR_EVENT_STARTEXECUTING	= 1 << GNOME_VFS_MONITOR_EVENT_STARTEXECUTING,
    MN_MAILBOX_MONITOR_EVENT_STOPEXECUTING	= 1 << GNOME_VFS_MONITOR_EVENT_STOPEXECUTING,
    MN_MAILBOX_MONITOR_EVENT_CREATED		= 1 << GNOME_VFS_MONITOR_EVENT_CREATED,
    MN_MAILBOX_MONITOR_EVENT_METADATA_CHANGED	= 1 << GNOME_VFS_MONITOR_EVENT_METADATA_CHANGED
  } MNMailboxMonitorEventType;
%}

%h{
#define MN_MAILBOX_N_TYPES		7
  extern GType mn_mailbox_types[MN_MAILBOX_N_TYPES + 1];

#define MN_MAILBOX_CAN_CHECK(self) \
  (MN_MAILBOX_GET_CLASS((self))->impl_check != NULL)
#define MN_MAILBOX_MUST_POLL(self) \
  (MN_MAILBOX_CAN_CHECK((self)) && ! mn_mailbox_get_automatic((self)))
%}
  
%{
#include "config.h"
#include <glib/gi18n.h>
#ifdef WITH_MBOX
#include "mn-mbox-mailbox.h"
#endif
#ifdef WITH_MH
#include "mn-mh-mailbox.h"
#endif
#ifdef WITH_MAILDIR
#include "mn-maildir-mailbox.h"
#endif
#ifdef WITH_POP3
#include "mn-pop3-mailbox.h"
#endif
#ifdef WITH_IMAP
#include "mn-imap-mailbox.h"
#endif
#ifdef WITH_SYLPHEED
#include "mn-sylpheed-mailbox.h"
#endif
#ifdef WITH_GMAIL
#include "mn-gmail-mailbox.h"
#endif
#include "mn-vfs.h"
#include "mn-util.h"
#include "mn-unsupported-mailbox.h"
#include "mn-conf.h"

typedef struct
{
  MNURI		*uri;
  void		(*callback)	(MNMailbox	*self,
				 gpointer	user_data);
  gpointer	user_data;
} NewInfo;

 GType mn_mailbox_types[MN_MAILBOX_N_TYPES + 1];
%}

/******************************************************************************
 *** IMPORTANT REMARKS ABOUT GDK LOCKING AND MULTI-THREADING ******************
 ******************************************************************************
 *
 * MNMailbox API functions must be called with the GDK lock
 * held. Exceptions are:
 *
 *	mn_mailbox_get_types()
 *	mn_mailbox_notice()
 *	mn_mailbox_set_init_error()
 *
 * (No code can be hooked to these functions through signals or other
 * means, therefore we are sure GDK will never be used from these
 * functions.)
 *
 * Mailboxes are constructed with the GDK lock not held. Use
 * GDK_THREADS_ENTER() and GDK_THREADS_LEAVE() where appropriate in
 * the construction phase.
 *
 * Virtual methods are called with the GDK lock not held.
 */

class MN:Mailbox from G:Object
{
  classwide const char *stock_id;
  classwide const char *format;

  /**
   * removed:
   * @self: the object which received the signal
   *
   * This signal gets emitted after the mailbox is removed from the
   * mailboxes list.
   **/
  signal NONE (NONE)
    void removed (self);

  public MNURI *uri = NULL unrefwith g_object_unref;
  property OBJECT uri (blurb = _("The mailbox URI"),
		       object_type = MN:URI,
		       flags = CONSTRUCT_ONLY)
    set
    {
      g_return_if_fail(self->uri == NULL);
      self->uri = MN_URI(g_value_dup_object(VAL));
      selfp->name = g_strdup(self->uri->human_readable);
    };
  
  private char *name destroywith g_free;
  property STRING name (blurb = _("The mailbox human-readable name"), link);
  public const char *get_name (self) { return selfp->name; }
  
  private gboolean automatic;
  property BOOLEAN automatic (blurb = _("Whether the mailbox has to be manually checked or not"),
			      link,
			      export);

  private gboolean has_new;
  property BOOLEAN has_new (blurb = _("Whether the mailbox has new mail or not"),
			    link,
			    export);

  private GSList *messages destroywith mn_g_object_slist_free;
  property POINTER messages (blurb = _("The list of new and unread MNMessage objects"),
			     export)
    set
    {
      GSList *messages;
      GSList *l;
      gboolean changed = FALSE;
      gboolean has_new = FALSE;

      messages = g_value_get_pointer(VAL);
      
      MN_LIST_FOREACH(l, selfp->messages)
	if (! mn_message_slist_find_by_id(messages, l->data))
	  {
	    changed = TRUE;
	    break;
	  }
      
      MN_LIST_FOREACH(l, messages)
	if (! mn_message_slist_find_by_id(selfp->messages, l->data))
	  {
	    changed = TRUE;
	    has_new = TRUE;
	    break;
	  }

      mn_g_object_slist_free(selfp->messages);
      selfp->messages = mn_g_object_slist_copy(messages);

      if (changed)
	self_messages_changed(self, has_new);
    }
    get
    {
      g_value_set_pointer(VAL, selfp->messages);
    };

  /**
   * messages-changed:
   * @self: the object which received the signal
   * @has_new: whether a new message has been received or not
   *
   * This signal gets emitted whenever the messages property changes.
   *
   * It is considered that the property changes if a new message
   * appears or if an old message disappears. If an existing message
   * changes while keeping the same id, this signal is not emitted
   * (use the "notify::messages" signal if you need notification of
   * such events).
   **/
  signal private NONE (BOOLEAN)
    void messages_changed (self, gboolean has_new);

  private char *error destroywith g_free;
  property STRING error (blurb = _("The mailbox error, if any"), link);
  protected void
    set_error (self, const char *format, ...)
  {
    va_list args;
    char *error = NULL;

    if (format)
      {
	va_start(args, format);
	error = g_strdup_vprintf(format, args);
	va_end(args);
      }
    
    g_object_set(G_OBJECT(self), MN_MAILBOX_PROP_ERROR(error), NULL);
    g_free(error);
  }
  public const char *get_error (self) { return selfp->error; }
  
  private GnomeVFSMonitorHandle *monitor_handle;
  private char *monitor_uri destroywith g_free;
  private MNMailboxMonitorEventType monitor_events;
  
  private gboolean checking;
  
  override (G:Object) void
    finalize (G:Object *object (check null type))
  {
    Self *self = SELF(object);

    if (selfp->monitor_handle)
      gnome_vfs_monitor_cancel(selfp->monitor_handle);

    PARENT_HANDLER(object);
  }
  
  public void
    init_types (void)
  {
    int i = 0;

#ifdef WITH_MBOX
    mn_mailbox_types[i++] = MN_TYPE_MBOX_MAILBOX;
#endif
#ifdef WITH_MH
    mn_mailbox_types[i++] = MN_TYPE_MH_MAILBOX;
#endif
#ifdef WITH_MAILDIR
    mn_mailbox_types[i++] = MN_TYPE_MAILDIR_MAILBOX;
#endif
#ifdef WITH_POP3
    mn_mailbox_types[i++] = MN_TYPE_POP3_MAILBOX;
#endif
#ifdef WITH_IMAP
    mn_mailbox_types[i++] = MN_TYPE_IMAP_MAILBOX;
#endif
#ifdef WITH_SYLPHEED
    mn_mailbox_types[i++] = MN_TYPE_SYLPHEED_MAILBOX;
#endif
#ifdef WITH_GMAIL
    mn_mailbox_types[i++] = MN_TYPE_GMAIL_MAILBOX;
#endif
    mn_mailbox_types[i] = 0;
  }

  /**
   * new_async:
   * @uri: location of the mailbox
   * @callback: a function like
   *            "void (callback) (#MNMailbox *self, gpointer user_data)"
   * @user_data: data to pass to @callback
   *
   * Creates a new #MNMailbox asynchronously. The newly created
   * #MNMailbox will be passed to @callback.
   **/
  public void
    new_async (MN:URI *uri (check null type),
	       gpointer callback (check null),
	       gpointer user_data)
  {
    NewInfo *info;

    info = g_new(NewInfo, 1);
    info->uri = g_object_ref(uri);
    info->callback = callback;
    info->user_data = user_data;

    mn_thread_create(self_new_async_thread, info);
  }

  private gpointer
    new_async_thread (gpointer data)
  {
    NewInfo *info = data;
    Self *mailbox = NULL;

    if (info->uri->vfs)
      {
	if (! mn_vfs_test(info->uri->vfs, G_FILE_TEST_EXISTS))
	  mailbox = mn_unsupported_mailbox_new(info->uri, _("does not exist"));
      }

    if (! mailbox)
      {
	int i;
	
	for (i = 0; mn_mailbox_types[i]; i++)
	  {
	    SelfClass *class;

	    class = g_type_class_peek(mn_mailbox_types[i]);
	    g_return_val_if_fail(class != NULL, NULL);

	    if (class->impl_is(NULL, info->uri))
	      {
		mailbox = g_object_new(mn_mailbox_types[i], MN_MAILBOX_PROP_URI(G_OBJECT(info->uri)), NULL);
		if (mailbox->_priv->init_error)
		  {
		    MNMailbox *old_mailbox;
		  
		    old_mailbox = mailbox;
		    mailbox = mn_unsupported_mailbox_new(info->uri, old_mailbox->_priv->init_error);
		    g_object_unref(old_mailbox);
		  }
		
		break;
	      }
	  }
      }

    if (! mailbox)
      mailbox = mn_unsupported_mailbox_new(info->uri, _("unknown format"));

    GDK_THREADS_ENTER();

    info->callback(mailbox, info->user_data);

    /*
     * A note on gdk_flush(): as adviced in the GDK threads
     * documentation, we only call gdk_flush() from a thread other
     * than our main thread (so we do not call it in idle and timeout
     * callbacks).
     */
    gdk_flush();
    GDK_THREADS_LEAVE();

    /* mailbox is now owned by the callback, do not unref it */
    
    g_object_unref(info->uri);
    g_free(info);

    return NULL;
  }
  
  private char *init_error destroywith g_free;
  protected void
    set_init_error (self, const char *format (check null), ...)
  {
    va_list args;

    g_return_if_fail(selfp->init_error == NULL);

    va_start(args, format);
    selfp->init_error = g_strdup_vprintf(format, args);
    va_end(args);
  }

  protected void
    monitor (self,
	     const char *uri (check null),
	     GnomeVFSMonitorType monitor_type,
	     MNMailboxMonitorEventType events)
  {
    GnomeVFSResult result;

    g_return_if_fail(MN_MAILBOX_CAN_CHECK(self));
    g_return_if_fail(selfp->monitor_handle == NULL);
    
    gdk_flush();
    GDK_THREADS_LEAVE();

    result = gnome_vfs_monitor_add(&selfp->monitor_handle,
				   uri,
				   monitor_type,
				   self_monitor_cb,
				   self);

    GDK_THREADS_ENTER();
    
    if (result == GNOME_VFS_OK)
      {
	selfp->monitor_uri = g_strdup(uri);
	selfp->monitor_events = events;
	self_set_automatic(self, TRUE);
      }
    else
      {
	g_warning(_("unable to enable immediate notification for %s: %s"), uri, gnome_vfs_result_to_string(result));

	if (! eel_gconf_get_boolean(MN_CONF_IMMEDIATE_NOTIFICATION_ERROR_DIALOG_DO_NOT_SHOW))
	  {
	    static gboolean first_time = TRUE;
	    
	    if (first_time)
	      {
		int minutes;
		int seconds;
		char *str;
	    
		first_time = FALSE;
	    
		minutes = eel_gconf_get_integer(MN_CONF_DELAY_MINUTES);
		seconds = eel_gconf_get_integer(MN_CONF_DELAY_SECONDS);
		
		if (minutes == 0)
		  str = g_strdup_printf(ngettext("As a fallback, they will be "
						 "checked every %i second (this "
						 "delay is configurable from the "
						 "Properties Dialog).",
						 "As a fallback, they will be "
						 "checked every %i seconds (this "
						 "delay is configurable from the "
						 "Properties Dialog).",
					     seconds),
					seconds);
		else if (seconds == 0)
		  str = g_strdup_printf(ngettext("As a fallback, they will be "
						 "checked every %i minute (this "
						 "delay is configurable from the "
						 "Properties Dialog).",
						 "As a fallback, they will be "
						 "checked every %i minutes (this "
						 "delay is configurable from the "
						 "Properties Dialog).",
						 minutes),
					minutes);
		else
		  str = g_strdup_printf(ngettext("As a fallback, they will be "
						 "checked approximately every %i "
						 "minute (this delay is "
						 "configurable from the "
						 "Properties Dialog).",
						 "As a fallback, they will be "
						 "checked approximately every %i "
						 "minutes (this delay is "
						 "configurable from the "
						 "Properties Dialog).",
						 minutes),
					minutes);
		
		mn_error_dialog(NULL,
				MN_CONF_IMMEDIATE_NOTIFICATION_ERROR_DIALOG_DO_NOT_SHOW,
				"immediate-notification",
				_("A monitoring error has occurred"),
				_("Mail Notification was unable to enable immediate "
				  "notification for one or more mailboxes. %s"), str);
		g_free(str);
	      }
	  }
      }
  }

  private void
    monitor_cb (GnomeVFSMonitorHandle *handle,
		const char *monitor_uri,
		const char *info_uri,
		GnomeVFSMonitorEventType event_type,
		gpointer user_data (check null))
  {
    Self *self = user_data;

    GDK_THREADS_ENTER();
    if (selfp->monitor_events & (1 << event_type))
      self_check(self);
    GDK_THREADS_LEAVE();
  }

  virtual private gboolean
    impl_is (self, MNURI *uri);
  virtual private void
    impl_check (self);
  
  public void
    check (self)
  {
    g_return_if_fail(MN_MAILBOX_CAN_CHECK(self));

    if (! selfp->checking)
      {
	g_object_ref(self);
	selfp->checking = TRUE;
	self_set_error(self, NULL);

	mn_thread_create((GThreadFunc) SELF_GET_CLASS(self)->impl_check, self);
      }
  }
  
  protected void
    end_check (self)
  {
    g_return_if_fail(selfp->checking == TRUE);

    selfp->checking = FALSE;
    g_object_unref(self);
  }
  
  protected void
    notice (self, const char *format (check null), ...)
  {
    va_list args;
    char *notice;
    
    va_start(args, format);
    notice = g_strdup_vprintf(format, args);
    va_end(args);

    mn_info("%s: %s", self->uri->text, notice);
    g_free(notice);
  }
}
