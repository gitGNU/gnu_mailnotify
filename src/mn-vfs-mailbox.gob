/* 
 * Copyright (C) 2005 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

requires 2.0.12

%headertop{
#include <libgnomevfs/gnome-vfs.h>
#include "mn-reentrant-mailbox.h"
%}

%h{
#define MN_VFS_MAILBOX_MAX_BACKEND_TYPES	4
extern GType mn_vfs_mailbox_backend_types[MN_VFS_MAILBOX_MAX_BACKEND_TYPES + 1];
%}

%privateheader{
#include "mn-vfs-mailbox-backend.h"
%}

%{
#include "config.h"
#include <glib/gi18n.h>
#ifdef WITH_MBOX
#include "mn-mbox-mailbox-backend.h"
#endif
#ifdef WITH_MH
#include "mn-mh-mailbox-backend.h"
#endif
#ifdef WITH_MAILDIR
#include "mn-maildir-mailbox-backend.h"
#endif
#ifdef WITH_SYLPHEED
#include "mn-sylpheed-mailbox-backend.h"
#endif
#include "mn-vfs.h"
#include "mn-stock.h"
#include "mn-conf.h"

GType mn_vfs_mailbox_backend_types[MN_VFS_MAILBOX_MAX_BACKEND_TYPES + 1];
%}

class MN:VFS:Mailbox from MN:Reentrant:Mailbox
{
  classwide const char *stock_id;

  public char *uri destroywith g_free;
  public GnomeVFSURI *vfs_uri unrefwith gnome_vfs_uri_unref;

  private GnomeVFSMonitorHandle *monitor_handle;

  private GnomeVFSResult type_monitor_result = GNOME_VFS_OK;
  protected GnomeVFSResult contents_monitor_result = GNOME_VFS_OK;

  private MNVFSMailboxBackend *backend unrefwith g_object_unref;
  
  public void
    init_types (void)
  {
    int i = 0;

#ifdef WITH_MBOX
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_MBOX_MAILBOX_BACKEND;
#endif
#ifdef WITH_MH
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_MH_MAILBOX_BACKEND;
#endif
#ifdef WITH_MAILDIR
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_MAILDIR_MAILBOX_BACKEND;
#endif
#ifdef WITH_SYLPHEED
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_SYLPHEED_MAILBOX_BACKEND;
#endif
    mn_vfs_mailbox_backend_types[i] = 0;
  }
  
  override (G:Object) GObject *
    constructor (GType type, unsigned int n_construct_properties, GObjectConstructParam *construct_params)
  {
    GObject *object;
    Self *self;
    SelfClass *class;

    object = PARENT_HANDLER(type, n_construct_properties, construct_params);
    self = SELF(object);
    class = SELF_GET_CLASS(self);

    if (class->stock_id)
      mn_mailbox_set_stock_id(MN_MAILBOX(self), (char *) class->stock_id);

    return object;
  }

  override (G:Object) void
    dispose (GObject *object)
  {
    Self *self = SELF(object);

    /*
     * We are no longer operational after dispose (see unrefwith
     * above), so we must remove our monitor.
     */
    if (selfp->monitor_handle)
      {
	gnome_vfs_monitor_cancel(selfp->monitor_handle);
	selfp->monitor_handle = NULL;
      }

    PARENT_HANDLER(object);
  }

  override (MN:Mailbox) void
    seal (MNMailbox *mailbox)
  {
    Self *self = SELF(mailbox);

    PARENT_HANDLER(mailbox);

    if (self->uri)
      {
	self->vfs_uri = gnome_vfs_uri_new(self->uri);

	if (! mailbox->runtime_name)
	  {
	    char *path;

	    path = gnome_vfs_get_local_path_from_uri(self->uri);
	    if (path)
	      {
		mailbox->runtime_name = g_filename_display_name(path);
		g_free(path);
	      }
	    else
	      mailbox->runtime_name = self->vfs_uri
		? gnome_vfs_uri_to_string(self->vfs_uri, GNOME_VFS_URI_HIDE_PASSWORD)
		: g_strdup(self->uri);
	  }
      }
  }
  
  private void
    monitor_cb (GnomeVFSMonitorHandle *handle,
		const char *monitor_uri,
		const char *info_uri,
		GnomeVFSMonitorEventType event_type,
		gpointer user_data)
  {
    if (event_type == GNOME_VFS_MONITOR_EVENT_CHANGED
	|| event_type == GNOME_VFS_MONITOR_EVENT_DELETED
	|| event_type == GNOME_VFS_MONITOR_EVENT_CREATED)
      {
	Self *self = user_data;
	mn_reentrant_mailbox_queue_check(MN_REENTRANT_MAILBOX(self));
      }
  }

  override (MN:Reentrant:Mailbox) void
    impl_check (MNReentrantMailbox *mailbox, unsigned long check_id)
  {
    Self *self = SELF(mailbox);
    MNVFSMailboxBackend *backend;
    GnomeVFSMonitorHandle *handle;
    GType backend_type = 0;
    gboolean exists;

    mn_reentrant_mailbox_lock(mailbox);

    handle = selfp->monitor_handle;

    backend = selfp->backend;
    if (backend)
      g_object_ref(backend);

    mn_reentrant_mailbox_unlock(mailbox);

    if (! handle)
      {
	GnomeVFSResult result;

	result = gnome_vfs_monitor_add(&handle,
				       self->uri,
				       GNOME_VFS_MONITOR_FILE,
				       self_monitor_cb,
				       self);

	if (result == GNOME_VFS_OK)
	  {
	    mn_reentrant_mailbox_lock(mailbox);

	    if (! selfp->monitor_handle)
	      {
		selfp->monitor_handle = handle;
		handle = NULL;
	      }

	    mn_reentrant_mailbox_unlock(mailbox);

	    if (handle)
	      gnome_vfs_monitor_cancel(handle);
	    else
	      {
		GDK_THREADS_ENTER();
		mn_mailbox_set_must_poll(MN_MAILBOX(self), FALSE);
		gdk_flush();
		GDK_THREADS_LEAVE();
	      }
	  }
	else
	  {
	    gboolean warn = FALSE;

	    mn_reentrant_mailbox_lock(mailbox);

	    if (! selfp->monitor_handle && result != selfp->type_monitor_result)
	      {
		warn = TRUE;
		selfp->type_monitor_result = result;
	      }

	    mn_reentrant_mailbox_unlock(mailbox);
	    
	    if (warn)
	      {
		mn_mailbox_warning(MN_MAILBOX(self), _("unable to monitor mailbox type (%s), poll mode activated"), gnome_vfs_result_to_string(result));
	    
		GDK_THREADS_ENTER();
		self_monitor_error_dialog();
		gdk_flush();
		GDK_THREADS_LEAVE();
	      }
	  }
      }
    
    if (backend && MN_VFS_MAILBOX_BACKEND_GET_CLASS(backend)->is(NULL, self))
      backend_type = G_OBJECT_TYPE(backend);
    else
      {
	exists = mn_vfs_test(self->vfs_uri, G_FILE_TEST_EXISTS);
	if (exists)
	  {
	    int i;

	    for (i = 0; mn_vfs_mailbox_backend_types[i]; i++)
	      {
		MNVFSMailboxBackendClass *class;
		
		class = g_type_class_peek(mn_vfs_mailbox_backend_types[i]);
		g_return_if_fail(class != NULL);
		
		if (class->is(NULL, self))
		  {
		    backend_type = mn_vfs_mailbox_backend_types[i];
		    break;
		  }
		
		if (mn_reentrant_mailbox_check_aborted(mailbox, check_id))
		  goto end;
	      }
	  }
      }
    
    if (! backend || backend_type != G_OBJECT_TYPE(backend))
      {
	gboolean is_local;
	MNVFSMailboxBackend *new_backend = NULL;

	is_local = gnome_vfs_uri_is_local(self->vfs_uri);

	GDK_THREADS_ENTER();

	if (! mn_reentrant_mailbox_check_aborted_unlocked(mailbox, check_id))
	  {
	    if (backend)
	      {
		/* reset must-poll and contents_monitor_result */
		mn_mailbox_set_must_poll(MN_MAILBOX(self), selfp->monitor_handle == NULL);
		self->contents_monitor_result = GNOME_VFS_OK;
	      }

	    if (backend_type)
	      {
		new_backend = g_object_new(backend_type, MN_VFS_MAILBOX_BACKEND_PROP_MAILBOX(self), NULL);

		mn_mailbox_set_format(MN_MAILBOX(self), (char *) MN_VFS_MAILBOX_BACKEND_GET_CLASS(new_backend)->format);
		if (! SELF_GET_CLASS(self)->stock_id)
		  mn_mailbox_set_stock_id(MN_MAILBOX(self), is_local ? MN_STOCK_LOCAL : MN_STOCK_REMOTE);
	      }
	    else
	      {
		mn_mailbox_set_format(MN_MAILBOX(self), NULL);
		if (! SELF_GET_CLASS(self)->stock_id)
		  mn_mailbox_set_stock_id(MN_MAILBOX(self), MN_STOCK_UNKNOWN);
		mn_mailbox_set_error(MN_MAILBOX(self), exists ? _("unknown mailbox format") : _("does not exist"));
	      }
	  }

	gdk_flush();
	GDK_THREADS_LEAVE();

	mn_reentrant_mailbox_lock(mailbox);

	if (backend)
	  {
	    g_object_unref(backend);
	    backend = NULL;
	  }

	if (! mn_reentrant_mailbox_check_aborted_unlocked(mailbox, check_id))
	  {
	    if (selfp->backend)
	      {
		g_object_unref(selfp->backend);
		selfp->backend = NULL;
	      }

	    if (new_backend)
	      {
		selfp->backend = backend = new_backend;
		new_backend = NULL;

		g_object_ref(backend);
	      }
	  }
	
	mn_reentrant_mailbox_unlock(mailbox);

	if (new_backend)
	  g_object_unref(new_backend);
      }
    
    if (backend)
      mn_vfs_mailbox_backend_check(backend, check_id);
    
  end:
    if (backend)
      {
	mn_reentrant_mailbox_lock(mailbox);
	g_object_unref(backend);
	mn_reentrant_mailbox_unlock(mailbox);
      }
  }

  protected void
    monitor_error_dialog (void)
  {
    static gboolean first_time = TRUE;
    int minutes;
    int seconds;
    char *str;

    if (! first_time)
      return;

    if (eel_gconf_get_boolean(MN_CONF_IMMEDIATE_NOTIFICATION_ERROR_DIALOG_DO_NOT_SHOW))
      return;

    first_time = FALSE;

    minutes = eel_gconf_get_integer(MN_CONF_DELAY_MINUTES);
    seconds = eel_gconf_get_integer(MN_CONF_DELAY_SECONDS);
		    
    if (minutes == 0)
      str = g_strdup_printf(ngettext("As a fallback, they will be "
				     "checked every %i second (this "
				     "delay is configurable from the "
				     "Properties Dialog).",
				     "As a fallback, they will be "
				     "checked every %i seconds (this "
				     "delay is configurable from the "
				     "Properties Dialog).",
				     seconds),
			    seconds);
    else if (seconds == 0)
      str = g_strdup_printf(ngettext("As a fallback, they will be "
				     "checked every %i minute (this "
				     "delay is configurable from the "
				     "Properties Dialog).",
				     "As a fallback, they will be "
				     "checked every %i minutes (this "
				     "delay is configurable from the "
				     "Properties Dialog).",
				     minutes),
			    minutes);
    else
      str = g_strdup_printf(ngettext("As a fallback, they will be "
				     "checked approximately every %i "
				     "minute (this delay is "
				     "configurable from the "
				     "Properties Dialog).",
				     "As a fallback, they will be "
				     "checked approximately every %i "
				     "minutes (this delay is "
				     "configurable from the "
				     "Properties Dialog).",
				     minutes),
			    minutes);
		    
    mn_error_dialog(NULL,
		    MN_CONF_IMMEDIATE_NOTIFICATION_ERROR_DIALOG_DO_NOT_SHOW,
		    "immediate-notification",
		    _("A monitoring error has occurred"),
		    _("Mail Notification was unable to enable immediate "
		      "notification for one or more mailboxes. %s"), str);
    g_free(str);
  }
}
