/* Generated by GOB (v2.0.14)   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 14

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "mn-vfs-mailbox.h"

#include "mn-vfs-mailbox-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 37 "mn-vfs-mailbox.gob"

#include "config.h"
#include <glib/gi18n.h>
#include "mn-mailbox-private.h"
#include "mn-reentrant-mailbox-private.h"
#if WITH_MBOX
#include "mn-mbox-mailbox-backend.h"
#endif
#if WITH_MOZILLA
#include "mn-mozilla-mailbox-backend.h"
#endif
#if WITH_MH
#include "mn-mh-mailbox-backend.h"
#endif
#if WITH_MAILDIR
#include "mn-maildir-mailbox-backend.h"
#endif
#if WITH_SYLPHEED
#include "mn-sylpheed-mailbox-backend.h"
#endif
#include "mn-vfs.h"
#include "mn-stock.h"
#include "mn-conf.h"
#include "mn-util.h"

GType mn_vfs_mailbox_backend_types[MN_VFS_MAILBOX_MAX_BACKEND_TYPES + 1];

typedef struct
{
  char				*uri;
  MNVFSMailboxBackend		*owner;
  GnomeVFSResult		result;
  GnomeVFSMonitorHandle		*handle;
} Monitor;

#line 62 "mn-vfs-mailbox.c"
/* self casting macros */
#define SELF(x) MN_VFS_MAILBOX(x)
#define SELF_CONST(x) MN_VFS_MAILBOX_CONST(x)
#define IS_SELF(x) MN_IS_VFS_MAILBOX(x)
#define TYPE_SELF MN_TYPE_VFS_MAILBOX
#define SELF_CLASS(x) MN_VFS_MAILBOX_CLASS(x)

#define SELF_GET_CLASS(x) MN_VFS_MAILBOX_GET_CLASS(x)

/* self typedefs */
typedef MNVFSMailbox Self;
typedef MNVFSMailboxClass SelfClass;

/* here are local prototypes */
static void mn_vfs_mailbox_init (MNVFSMailbox * o) G_GNUC_UNUSED;
static void mn_vfs_mailbox_class_init (MNVFSMailboxClass * class) G_GNUC_UNUSED;
static GObject * ___3_mn_vfs_mailbox_constructor (GType type, unsigned int n_construct_properties, GObjectConstructParam * construct_params) G_GNUC_UNUSED;
static void ___4_mn_vfs_mailbox_dispose (GObject * object) G_GNUC_UNUSED;
static void ___5_mn_vfs_mailbox_seal (MNMailbox * mailbox) G_GNUC_UNUSED;
static void mn_vfs_mailbox_monitor_free (Monitor * monitor) G_GNUC_UNUSED;
static void mn_vfs_mailbox_monitor_cb (GnomeVFSMonitorHandle * handle, const char * monitor_uri, const char * info_uri, GnomeVFSMonitorEventType event_type, gpointer user_data) G_GNUC_UNUSED;
static void mn_vfs_mailbox_queue_update_poll (MNVFSMailbox * self) G_GNUC_UNUSED;
static gboolean mn_vfs_mailbox_update_poll_cb (gpointer data) G_GNUC_UNUSED;
static void ___c_mn_vfs_mailbox_reentrant_check (MNReentrantMailbox * mailbox, unsigned long check_id) G_GNUC_UNUSED;

/* pointer to the class of our parent */
static MNReentrantMailboxClass *parent_class = NULL;

/* Short form macros */
#define self_init_types mn_vfs_mailbox_init_types
#define self_monitor mn_vfs_mailbox_monitor
#define self_monitor_free mn_vfs_mailbox_monitor_free
#define self_monitor_cb mn_vfs_mailbox_monitor_cb
#define self_remove_monitors_by_owner mn_vfs_mailbox_remove_monitors_by_owner
#define self_queue_update_poll mn_vfs_mailbox_queue_update_poll
#define self_update_poll_cb mn_vfs_mailbox_update_poll_cb
GType
mn_vfs_mailbox_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (MNVFSMailboxClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) mn_vfs_mailbox_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (MNVFSMailbox),
			0 /* n_preallocs */,
			(GInstanceInitFunc) mn_vfs_mailbox_init,
			NULL
		};

		type = g_type_register_static (MN_TYPE_REENTRANT_MAILBOX, "MNVFSMailbox", &info, (GTypeFlags)G_TYPE_FLAG_ABSTRACT);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((MNVFSMailbox *)g_object_new(mn_vfs_mailbox_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static MNVFSMailbox * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static MNVFSMailbox *
GET_NEW_VARG (const char *first, ...)
{
	MNVFSMailbox *ret;
	va_list ap;
	va_start (ap, first);
	ret = (MNVFSMailbox *)g_object_new_valist (mn_vfs_mailbox_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___dispose (GObject *obj_self)
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::dispose"
	MNVFSMailbox *self G_GNUC_UNUSED = MN_VFS_MAILBOX (obj_self);
#line 141 "mn-vfs-mailbox.gob"
	___4_mn_vfs_mailbox_dispose(obj_self);
#line 149 "mn-vfs-mailbox.c"
#line 78 "mn-vfs-mailbox.gob"
	if(self->vfs_uri) { gnome_vfs_uri_unref ((gpointer) self->vfs_uri); self->vfs_uri = NULL; }
#line 152 "mn-vfs-mailbox.c"
#line 81 "mn-vfs-mailbox.gob"
	if(self->_priv->backend) { g_object_unref ((gpointer) self->_priv->backend); self->_priv->backend = NULL; }
#line 155 "mn-vfs-mailbox.c"
}
#undef __GOB_FUNCTION__


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::finalize"
	MNVFSMailbox *self G_GNUC_UNUSED = MN_VFS_MAILBOX (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
#line 77 "mn-vfs-mailbox.gob"
	if(self->uri) { g_free ((gpointer) self->uri); self->uri = NULL; }
#line 170 "mn-vfs-mailbox.c"
}
#undef __GOB_FUNCTION__

static void 
mn_vfs_mailbox_init (MNVFSMailbox * o G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::init"
	o->_priv = G_TYPE_INSTANCE_GET_PRIVATE(o,MN_TYPE_VFS_MAILBOX,MNVFSMailboxPrivate);
}
#undef __GOB_FUNCTION__
#line 107 "mn-vfs-mailbox.gob"
static void 
mn_vfs_mailbox_class_init (MNVFSMailboxClass * class G_GNUC_UNUSED)
#line 184 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) class;
	MNMailboxClass *mn_mailbox_class = (MNMailboxClass *)class;
	MNReentrantMailboxClass *mn_reentrant_mailbox_class = (MNReentrantMailboxClass *)class;

	g_type_class_add_private(class,sizeof(MNVFSMailboxPrivate));

	parent_class = g_type_class_ref (MN_TYPE_REENTRANT_MAILBOX);

#line 117 "mn-vfs-mailbox.gob"
	g_object_class->constructor = ___3_mn_vfs_mailbox_constructor;
#line 141 "mn-vfs-mailbox.gob"
	g_object_class->dispose = ___dispose;
#line 156 "mn-vfs-mailbox.gob"
	mn_mailbox_class->seal = ___5_mn_vfs_mailbox_seal;
#line 322 "mn-vfs-mailbox.gob"
	mn_reentrant_mailbox_class->reentrant_check = ___c_mn_vfs_mailbox_reentrant_check;
#line 203 "mn-vfs-mailbox.c"
	g_object_class->finalize = ___finalize;
 {
#line 108 "mn-vfs-mailbox.gob"

    /*
     * Most VFS mailboxes will probably be local files, or remote
     * files located in the same LAN. We therefore choose a small
     * default check delay (1 minute).
     */
    MN_MAILBOX_CLASS(class)->default_check_delay = 60 * 1;
  
#line 215 "mn-vfs-mailbox.c"
 }
}
#undef __GOB_FUNCTION__


#line 84 "mn-vfs-mailbox.gob"
void 
mn_vfs_mailbox_init_types (void)
#line 224 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::init_types"
{
#line 86 "mn-vfs-mailbox.gob"
	
    int i = 0;

#if WITH_MBOX
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_MBOX_MAILBOX_BACKEND;
#endif
#if WITH_MOZILLA
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_MOZILLA_MAILBOX_BACKEND;
#endif
#if WITH_MH
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_MH_MAILBOX_BACKEND;
#endif
#if WITH_MAILDIR
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_MAILDIR_MAILBOX_BACKEND;
#endif
#if WITH_SYLPHEED
    mn_vfs_mailbox_backend_types[i++] = MN_TYPE_SYLPHEED_MAILBOX_BACKEND;
#endif
    mn_vfs_mailbox_backend_types[i] = 0;
  }}
#line 249 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__


#line 117 "mn-vfs-mailbox.gob"
static GObject * 
___3_mn_vfs_mailbox_constructor (GType type G_GNUC_UNUSED, unsigned int n_construct_properties, GObjectConstructParam * construct_params)
#line 256 "mn-vfs-mailbox.c"
#define PARENT_HANDLER(___type,___n_construct_properties,___construct_params) \
	((G_OBJECT_CLASS(parent_class)->constructor)? \
		(* G_OBJECT_CLASS(parent_class)->constructor)(___type,___n_construct_properties,___construct_params): \
		((GObject * )0))
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::constructor"
{
#line 119 "mn-vfs-mailbox.gob"
	
    GObject *object;
    Self *self;
    SelfClass *class;

    object = PARENT_HANDLER(type, n_construct_properties, construct_params);
    self = SELF(object);
    class = SELF_GET_CLASS(self);

    /* set default poll to the most likely value */
    mn_mailbox_set_poll(MN_MAILBOX(self), FALSE);

    /*
     * We must do this in constructor() and not init() because
     * class->stock_id is not yet assigned in init().
     */
    if (class->stock_id)
      mn_mailbox_set_stock_id(MN_MAILBOX(self), (char *) class->stock_id);

    return object;
  }}
#line 286 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 141 "mn-vfs-mailbox.gob"
static void 
___4_mn_vfs_mailbox_dispose (GObject * object G_GNUC_UNUSED)
#line 293 "mn-vfs-mailbox.c"
#define PARENT_HANDLER(___object) \
	{ if(G_OBJECT_CLASS(parent_class)->dispose) \
		(* G_OBJECT_CLASS(parent_class)->dispose)(___object); }
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::dispose"
{
#line 143 "mn-vfs-mailbox.gob"
	
    Self *self = SELF(object);

    /*
     * We are no longer operational after dispose (see unrefwith
     * above), so we must remove our monitors.
     */
    mn_locked_g_source_clear(&selfp->update_poll_source);
    mn_g_slist_clear_deep_custom(&selfp->monitors, (GFunc) self_monitor_free, NULL);

    PARENT_HANDLER(object);
  }}
#line 313 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 156 "mn-vfs-mailbox.gob"
static void 
___5_mn_vfs_mailbox_seal (MNMailbox * mailbox G_GNUC_UNUSED)
#line 320 "mn-vfs-mailbox.c"
#define PARENT_HANDLER(___mailbox) \
	{ if(MN_MAILBOX_CLASS(parent_class)->seal) \
		(* MN_MAILBOX_CLASS(parent_class)->seal)(___mailbox); }
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::seal"
{
#line 158 "mn-vfs-mailbox.gob"
	
    Self *self = SELF(mailbox);

    PARENT_HANDLER(mailbox);

    if (self->uri)
      {
	self->vfs_uri = gnome_vfs_uri_new(self->uri);

	if (! mailbox->runtime_name)
	  {
	    char *path;

	    path = gnome_vfs_get_local_path_from_uri(self->uri);
	    if (path)
	      {
		mailbox->runtime_name = g_filename_display_name(path);
		g_free(path);
	      }
	    else
	      mailbox->runtime_name = self->vfs_uri
		? gnome_vfs_uri_to_string(self->vfs_uri, GNOME_VFS_URI_HIDE_PASSWORD)
		: g_strdup(self->uri);
	  }
      }
  }}
#line 354 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 185 "mn-vfs-mailbox.gob"
void 
mn_vfs_mailbox_monitor (MNVFSMailbox * self, const char * uri, MNVFSMailboxBackend * owner, GnomeVFSMonitorType type, GnomeVFSMonitorCallback callback, gpointer user_data)
#line 361 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::monitor"
#line 185 "mn-vfs-mailbox.gob"
	g_return_if_fail (self != NULL);
#line 185 "mn-vfs-mailbox.gob"
	g_return_if_fail (MN_IS_VFS_MAILBOX (self));
#line 185 "mn-vfs-mailbox.gob"
	g_return_if_fail (uri != NULL);
#line 370 "mn-vfs-mailbox.c"
{
#line 192 "mn-vfs-mailbox.gob"
	
    Monitor *monitor = NULL;
    GSList *l;

    g_return_if_fail(owner == NULL || MN_IS_VFS_MAILBOX_BACKEND(owner));

    MN_LIST_FOREACH(l, selfp->monitors)
      {
	Monitor *this_monitor = l->data;

	if (this_monitor->owner == owner && ! strcmp(this_monitor->uri, uri))
	  {
	    monitor = this_monitor;
	    break;
	  }
      }

    if (! monitor)
      {
	monitor = g_new0(Monitor, 1);
	monitor->uri = g_strdup(uri);
	monitor->owner = owner;
	monitor->result = -1;

	selfp->monitors = g_slist_append(selfp->monitors, monitor);
      }

    if (monitor->result != GNOME_VFS_OK)
      {
	GnomeVFSResult result;

	result = mn_gnome_vfs_monitor_add_locked(&monitor->handle, uri, type, callback, user_data);
	if (result != monitor->result)
	  {
	    monitor->result = result;
	    if (result != GNOME_VFS_OK)
	      mn_mailbox_warning(MN_MAILBOX(self), _("unable to monitor %s (%s), poll mode activated"), uri, gnome_vfs_result_to_string(result));

	    self_queue_update_poll(self);
	  }
      }
  }}
#line 415 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__

#line 235 "mn-vfs-mailbox.gob"
static void 
mn_vfs_mailbox_monitor_free (Monitor * monitor)
#line 421 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::monitor_free"
#line 235 "mn-vfs-mailbox.gob"
	g_return_if_fail (monitor != NULL);
#line 426 "mn-vfs-mailbox.c"
{
#line 237 "mn-vfs-mailbox.gob"
	
    g_free(monitor->uri);

    if (monitor->result == GNOME_VFS_OK)
      mn_gnome_vfs_monitor_cancel_locked(monitor->handle);

    g_free(monitor);
  }}
#line 437 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__

#line 246 "mn-vfs-mailbox.gob"
static void 
mn_vfs_mailbox_monitor_cb (GnomeVFSMonitorHandle * handle, const char * monitor_uri, const char * info_uri, GnomeVFSMonitorEventType event_type, gpointer user_data)
#line 443 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::monitor_cb"
{
#line 252 "mn-vfs-mailbox.gob"
	
    if (event_type == GNOME_VFS_MONITOR_EVENT_CHANGED
	|| event_type == GNOME_VFS_MONITOR_EVENT_DELETED
	|| event_type == GNOME_VFS_MONITOR_EVENT_CREATED)
      {
	Self *self = user_data;
	mn_reentrant_mailbox_queue_check(MN_REENTRANT_MAILBOX(self));
      }
  }}
#line 457 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__

#line 262 "mn-vfs-mailbox.gob"
void 
mn_vfs_mailbox_remove_monitors_by_owner (MNVFSMailbox * self, MNVFSMailboxBackend * owner)
#line 463 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::remove_monitors_by_owner"
#line 262 "mn-vfs-mailbox.gob"
	g_return_if_fail (self != NULL);
#line 262 "mn-vfs-mailbox.gob"
	g_return_if_fail (MN_IS_VFS_MAILBOX (self));
#line 470 "mn-vfs-mailbox.c"
{
#line 264 "mn-vfs-mailbox.gob"
	
    GSList *l;

    g_return_if_fail(owner == NULL || MN_IS_VFS_MAILBOX_BACKEND(owner));

  start:
    MN_LIST_FOREACH(l, selfp->monitors)
      {
	Monitor *monitor = l->data;

	if (monitor->owner == owner)
	  {
	    selfp->monitors = mn_g_slist_delete_link_deep_custom(selfp->monitors, l, (GFunc) self_monitor_free, NULL);
	    self_queue_update_poll(self);
	    goto start;
	  }
      }
  }}
#line 491 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__

#line 283 "mn-vfs-mailbox.gob"
static void 
mn_vfs_mailbox_queue_update_poll (MNVFSMailbox * self)
#line 497 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::queue_update_poll"
#line 283 "mn-vfs-mailbox.gob"
	g_return_if_fail (self != NULL);
#line 283 "mn-vfs-mailbox.gob"
	g_return_if_fail (MN_IS_VFS_MAILBOX (self));
#line 504 "mn-vfs-mailbox.c"
{
#line 285 "mn-vfs-mailbox.gob"
	
    if (selfp->update_poll_source)
      mn_locked_g_source_remove(selfp->update_poll_source);

    selfp->update_poll_source = mn_g_idle_add_gdk_locked(self_update_poll_cb, self);
  }}
#line 513 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__

#line 292 "mn-vfs-mailbox.gob"
static gboolean 
mn_vfs_mailbox_update_poll_cb (gpointer data)
#line 519 "mn-vfs-mailbox.c"
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::update_poll_cb"
{
#line 294 "mn-vfs-mailbox.gob"
	
    Self *self = data;
    gboolean polled = FALSE;
    GSList *l;

    mn_reentrant_mailbox_lock(MN_REENTRANT_MAILBOX(self));

    MN_LIST_FOREACH(l, selfp->monitors)
      {
	Monitor *monitor = l->data;

	if (monitor->result != GNOME_VFS_OK)
	  {
	    polled = TRUE;
	    break;
	  }
      }

    selfp->update_poll_source = NULL;

    mn_reentrant_mailbox_unlock(MN_REENTRANT_MAILBOX(self));

    if (mn_mailbox_get_poll(MN_MAILBOX(self)) != polled)
      mn_mailbox_set_poll(MN_MAILBOX(self), polled);

    return FALSE;		/* remove source */
  }}
#line 551 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__

#line 322 "mn-vfs-mailbox.gob"
static void 
___c_mn_vfs_mailbox_reentrant_check (MNReentrantMailbox * mailbox G_GNUC_UNUSED, unsigned long check_id)
#line 557 "mn-vfs-mailbox.c"
#define PARENT_HANDLER(___mailbox,___check_id) \
	{ if(MN_REENTRANT_MAILBOX_CLASS(parent_class)->reentrant_check) \
		(* MN_REENTRANT_MAILBOX_CLASS(parent_class)->reentrant_check)(___mailbox,___check_id); }
{
#define __GOB_FUNCTION__ "MN:VFS:Mailbox::reentrant_check"
{
#line 324 "mn-vfs-mailbox.gob"
	
    Self *self = SELF(mailbox);
    MNVFSMailboxBackend *backend;
    MNVFSMailboxBackendClass *class;
    GType backend_type = 0;
    gboolean exists;

    mn_reentrant_mailbox_lock(mailbox);

    self_monitor(self, self->uri, NULL, GNOME_VFS_MONITOR_FILE, self_monitor_cb, self);

    backend = selfp->backend;
    if (backend)
      g_object_ref(backend);

    mn_reentrant_mailbox_unlock(mailbox);

    class = backend ? MN_VFS_MAILBOX_BACKEND_GET_CLASS(backend) : NULL;
    if (class && class->is(NULL, class, self))
      backend_type = G_OBJECT_TYPE(backend);
    else
      {
	exists = mn_vfs_test(self->vfs_uri, G_FILE_TEST_EXISTS);
	if (exists)
	  {
	    int i;

	    for (i = 0; mn_vfs_mailbox_backend_types[i]; i++)
	      {
		class = g_type_class_peek(mn_vfs_mailbox_backend_types[i]);
		g_assert(class != NULL);

		if (class->is(NULL, class, self))
		  {
		    backend_type = mn_vfs_mailbox_backend_types[i];
		    break;
		  }

		if (mn_reentrant_mailbox_check_aborted(mailbox, check_id))
		  goto end;
	      }
	  }
      }

    if (! backend || backend_type != G_OBJECT_TYPE(backend))
      {
	gboolean is_local;
	MNVFSMailboxBackend *new_backend = NULL;

	is_local = gnome_vfs_uri_is_local(self->vfs_uri);

	GDK_THREADS_ENTER();

	if (! mn_reentrant_mailbox_check_aborted_unlocked(mailbox, check_id))
	  {
	    if (backend_type)
	      {
		new_backend = g_object_new(backend_type, MN_VFS_MAILBOX_BACKEND_PROP_MAILBOX(self), NULL);

		mn_mailbox_set_format(MN_MAILBOX(self), (char *) MN_VFS_MAILBOX_BACKEND_GET_CLASS(new_backend)->format);
		if (! SELF_GET_CLASS(self)->stock_id)
		  mn_mailbox_set_stock_id(MN_MAILBOX(self), is_local ? MN_STOCK_LOCAL : MN_STOCK_REMOTE);
	      }
	    else
	      {
		mn_mailbox_set_format(MN_MAILBOX(self), NULL);
		if (! SELF_GET_CLASS(self)->stock_id)
		  mn_mailbox_set_stock_id(MN_MAILBOX(self), MN_STOCK_UNKNOWN);
		mn_mailbox_set_error(MN_MAILBOX(self), exists ? _("unknown mailbox format") : _("does not exist"));
	      }
	  }

	gdk_flush();
	GDK_THREADS_LEAVE();

	mn_reentrant_mailbox_lock(mailbox);

	if (backend)
	  {
	    g_object_unref(backend);
	    backend = NULL;
	  }

	if (! mn_reentrant_mailbox_check_aborted_unlocked(mailbox, check_id))
	  {
	    if (selfp->backend)
	      {
		g_object_unref(selfp->backend);
		selfp->backend = NULL;
	      }

	    if (new_backend)
	      {
		selfp->backend = backend = new_backend;
		new_backend = NULL;

		g_object_ref(backend);
	      }
	  }

	mn_reentrant_mailbox_unlock(mailbox);

	if (new_backend)
	  g_object_unref(new_backend);
      }

    if (backend)
      mn_vfs_mailbox_backend_check(backend, check_id);

  end:
    if (backend)
      {
	mn_reentrant_mailbox_lock(mailbox);
	g_object_unref(backend);
	mn_reentrant_mailbox_unlock(mailbox);
      }
  }}
#line 682 "mn-vfs-mailbox.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER
