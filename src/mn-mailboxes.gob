/* 
 * Copyright (C) 2004, 2005 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

requires 2.0.10

%headertop{
#include "mn-mailbox.h"
%}
%{
#include "config.h"
#include <glib/gi18n.h>
#include <eel/eel.h>
#include "mn-conf.h"
#include "mn-util.h"
#include "mn-pending-mailbox.h"
#include "mn-unsupported-mailbox.h"
%}

class MN:Mailboxes from G:Object
{
  private GSList *list destroywith mn_g_object_slist_free;
  private unsigned int timeout_id;
    
  /**
   * mailbox-added:
   * @self: the object which received the signal
   * @mailbox: the mailbox which is about to be added
   *
   * This signal gets emitted after a mailbox is added to the list.
   **/
  signal private NONE (OBJECT)
    void mailbox_added (self, MN:Mailbox *mailbox (check null type));

  /**
   * mailbox-changed:
   * @self: the object which received the signal
   * @mailbox: the mailbox which has changed
   *
   * This signal gets emitted after a mailbox changes type.
   **/
  signal private NONE (OBJECT)
    void mailbox_changed (self, MN:Mailbox *mailbox (check null type));

  /**
   * mailbox-removed:
   * @self: the object which received the signal
   * @mailbox: the mailbox which is about to be removed
   *
   * This signal gets emitted after a mailbox is removed from the
   * list.
   **/
  signal first private NONE (OBJECT)
    void mailbox_removed (self, MN:Mailbox *mailbox (check null type))
  {
    /* disconnect signals */
    g_object_disconnect(mailbox,
			"any-signal", self_messages_changed_h, self,
			"any-signal", self_notify_error_h, self,
			"any-signal", self_notify_must_poll_h, self,
			NULL);

    /* emit the "removed" signal on the mailbox */
    mn_mailbox_removed(mailbox);

    /* messages and error have possibly changed */
    self_messages_changed(self, FALSE);
    self_error_changed(self);
  }
  
  /**
   * list-changed:
   * @self: the object which received the signal
   *
   * This signal gets emitted after the mailbox list changes (but more
   * than one mailbox may have been added, removed or have changed
   * between two emissions of this signal).
   **/
  signal first private NONE (NONE)
    void list_changed (self)
  {
    /* must-poll has possibly changed */
    g_object_notify(G_OBJECT(self), "must-poll");
  }
  
  /**
   * messages-changed:
   * @self: the object which received the signal
   * @has_new: whether a new message has been received or not
   *
   * This signal gets emitted whenever a call to
   * mn_mailboxes_get_messages() may possibly lead to a different list
   * than before the signal emission, either because one of the
   * mailboxes messages property has changed, or because a mailbox has
   * been removed from the list.
   *
   * Note: messages are only compared by id, therefore two messages
   * having the same id and different data are not considered
   * different.
   **/
  signal private NONE (BOOLEAN)
    void messages_changed (self, gboolean has_new);

  /**
   * error-changed:
   * @self: the object which received the signal
   *
   * This signal gets emitted whenever the global error state has
   * possibly changed, either because one of the mailboxes error
   * property has changed, or because a mailbox has been removed from
   * the list.
   **/
  signal private NONE (NONE)
    void error_changed (self);

  property BOOLEAN must_poll (blurb = _("Whether one or more of the mailboxes has to be polled"),
			      export)
    get
    {
      gboolean must_poll = FALSE;
      GSList *l;

      MN_LIST_FOREACH(l, selfp->list)
	if (MN_MAILBOX_MUST_POLL(l->data))
	  {
	    must_poll = TRUE;
	    break;
	  }

      g_value_set_boolean(VAL, must_poll);
    };

  init (self)
  {
    self_update_from_conf(self);
    self_install_timeout(self);

    mn_conf_notification_add(self, MN_CONF_DELAY_NAMESPACE, self_notify_delay_cb, self);
    mn_conf_notification_add(self, MN_CONF_MAILBOXES, self_notify_mailboxes_cb, self);
  }
  
  override (G:Object) void
    finalize (G:Object *object (check null type))
  {
    Self *self = SELF(object);

    if (selfp->timeout_id)
      g_source_remove(selfp->timeout_id);

    PARENT_HANDLER(object);
  }

  private void
    notify_delay_cb (GConfClient *client,
		     unsigned int cnxn_id,
		     GConfEntry *entry,
		     gpointer user_data (check null))
  {
    Self *self = user_data;

    GDK_THREADS_ENTER();
    self_install_timeout(self);
    GDK_THREADS_LEAVE();
  }

  private void
    notify_mailboxes_cb (GConfClient *client,
			 unsigned int cnxn_id,
			 GConfEntry *entry,
			 gpointer user_data (check null))
  {
    Self *self = user_data;

    GDK_THREADS_ENTER();
    self_update_from_conf(self);
    GDK_THREADS_LEAVE();
  }
  
  private void
    update_from_conf (self)
  {
    GSList *gconf_mailboxes;
    GSList *l;
    gboolean changed = FALSE;

    gconf_mailboxes = eel_gconf_get_string_list(MN_CONF_MAILBOXES);

    /* first step: remove old mailboxes */

  loop:
    MN_LIST_FOREACH(l, selfp->list)
      {
	MNMailbox *mailbox = l->data;

	if (! self_conf_find_uri(gconf_mailboxes, mailbox->uri))
	  {
	    selfp->list = g_slist_delete_link(selfp->list, l);

	    self_mailbox_removed(self, mailbox);
	    g_object_unref(mailbox);

	    changed = TRUE;
	    goto loop;
	  }
      }

    /* second step: add new mailboxes */

    MN_LIST_FOREACH(l, gconf_mailboxes)
      {
	const char *text_uri = l->data;
	MNURI *uri;
      
	uri = mn_uri_new(text_uri);
	if (! self_find_uri(self, uri))
	  {
	    MNMailbox *mailbox;

	    mailbox = mn_pending_mailbox_new(uri);
	    selfp->list = g_slist_append(selfp->list, mailbox);

	    self_mailbox_added(self, mailbox);
	    changed = TRUE;
	    
	    mn_mailbox_new_async(uri, self_new_cb, self);
	  }
	g_object_unref(uri);
      }

    eel_g_slist_free_deep(gconf_mailboxes);
    if (changed)
      self_list_changed(self);
  }

  private void
    new_cb (MN:Mailbox *mailbox (check null type),
	    gpointer user_data (check null))
  {
    Self *self = user_data;
    GSList *elem;

    elem = self_find_uri(self, mailbox->uri);
    if (elem)
      {
	if (MN_IS_UNSUPPORTED_MAILBOX(mailbox))
	  mn_info(_("%s is unsupported: %s"), mn_mailbox_get_name(mailbox), mn_unsupported_mailbox_get_reason(MN_UNSUPPORTED_MAILBOX(mailbox)));
	
	g_object_connect(mailbox,
			 "signal::messages-changed", self_messages_changed_h, self,
			 "signal::notify::error", self_notify_error_h, self,
			 "signal::notify::must-poll", self_notify_must_poll_h, self,
			 NULL);

	if (MN_MAILBOX_CAN_CHECK(mailbox))
	  mn_mailbox_check(mailbox);

	g_object_unref(elem->data);
	elem->data = mailbox;

	self_mailbox_changed(self, mailbox);
	self_list_changed(self);
      }
    else
      g_object_unref(mailbox);
  }

  private void
    messages_changed_h (MN:Mailbox *mailbox (check null type),
			gboolean has_new,
			gpointer user_data (check null))
  {
    Self *self = user_data;
    int n_messages;

    n_messages = g_slist_length(mn_mailbox_get_messages(mailbox));
    mn_info(ngettext("%s has %i new message", "%s has %i new messages", n_messages),
	    mn_mailbox_get_name(mailbox), n_messages);
    
    self_messages_changed(self, has_new);
  }
  
  private void
    notify_error_h (G:Object *object (check null type),
		    GParamSpec *pspec (check null),
		    gpointer user_data (check null))
  {
    Self *self = user_data;
    MNMailbox *mailbox = MN_MAILBOX(object);
    const char *error;

    error = mn_mailbox_get_error(mailbox);
    if (error)
      mn_info(_("%s reported an error: %s"), mn_mailbox_get_name(mailbox), error);

    self_error_changed(self);
  }

  private void
    notify_must_poll_h (G:Object *object (check null type),
			GParamSpec *pspec (check null),
			gpointer user_data (check null))
  {
    Self *self = user_data;

    /* must-poll has possibly changed */
    g_object_notify(G_OBJECT(self), "must-poll");
  }
  
  private void
    install_timeout (self)
  {
    mn_source_remove(&selfp->timeout_id);
    selfp->timeout_id = mn_timeout_add(MN_CONF_DELAY_MINUTES,
				       MN_CONF_DELAY_SECONDS,
				       self_timeout_cb,
				       self);
  }

  private gboolean
    timeout_cb (gpointer data (check null))
  {
    Self *self = data;

    GDK_THREADS_ENTER();
    self_check(self);
    GDK_THREADS_LEAVE();
    
    return TRUE;		/* continue */
  }

  public void
    check (self)
  {
    GSList *l;

    MN_LIST_FOREACH(l, selfp->list)
      {
	MNMailbox *mailbox = l->data;

	if (MN_MAILBOX_MUST_POLL(mailbox))
	  mn_mailbox_check(mailbox);
      }
  }

  public GSList *
    get (self)
  {
    return selfp->list;
  }

  public GSList *
    get_messages (self)
  {
    GSList *messages = NULL;
    GSList *l;

    MN_LIST_FOREACH(l, selfp->list)
      {
	MNMailbox *mailbox = l->data;
	messages = g_slist_concat(messages, mn_g_object_slist_copy(mn_mailbox_get_messages(mailbox)));
      }

    messages = mn_message_slist_sort_by_sent_time(messages);
    messages = g_slist_reverse(messages);

    return messages;
  }
  
  public GSList *
    find (self, const char *text_uri (check null))
  {
    MNURI *uri;
    GSList *elem;

    uri = mn_uri_new(text_uri);
    elem = self_find_uri(self, uri);
    g_object_unref(uri);

    return elem;
  }
  
  public GSList *
    find_uri (self, MN:URI *uri (check null type))
  {
    return g_slist_find_custom(selfp->list, uri, self_find_compare_func);
  }
  
  private int
    find_compare_func (gconstpointer a, gconstpointer b)
  {
    MNMailbox *mailbox = (MNMailbox *) a;
    MNURI *uri = (MNURI *) b;

    return strcmp(mailbox->uri->text, uri->text);
  }

  public GSList *
    conf_find_uri (GSList *gconf_mailboxes, MN:URI *uri (check null type))
  {
    return g_slist_find_custom(gconf_mailboxes, uri, self_conf_find_compare_func);
  }
  
  private int
    conf_find_compare_func (gconstpointer a, gconstpointer b)
  {
    MNURI *uri_a;
    MNURI *uri_b = (MNURI *) b;
    int cmp;

    uri_a = mn_uri_new(a);
    cmp = strcmp(uri_a->text, uri_b->text);
    g_object_unref(uri_a);

    return cmp;
  }
  
  public MNMailboxes *
    new (void)
  {
    return GET_NEW;
  }
}
