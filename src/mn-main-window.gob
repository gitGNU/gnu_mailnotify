/* 
 * Copyright (C) 2005 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

requires 2.0.12

%headertop{
#include <gtk/gtk.h>
%}

%privateheader{
#include "egg-toolbars-model.h"
%}

%{
#include "config.h"
#include <gnome.h>
#include <eel/eel.h>
#include "egg-editable-toolbar.h"
#include "egg-toolbar-editor.h"
#include "mn-util.h"
#include "mn-stock.h"
#include "mn-shell.h"
#include "mn-conf.h"
#include "mn-properties-dialog.h"
#include "mn-message-view.h"

#define STATUS_PUSH(cid, str) \
  gtk_statusbar_push(GTK_STATUSBAR(selfp->statusbar), (cid), (str))
#define STATUS_POP(cid) \
  gtk_statusbar_pop(GTK_STATUSBAR(selfp->statusbar), (cid))
#define GET_ACTION(name) \
  gtk_action_group_get_action(selfp->action_group, (name))
#define FULLSCREEN \
  (selfp->leave_fullscreen_popup != NULL)
%}

class MN:Main:Window from Gtk:Window
{
  private GtkWidget *menubar;
  private GtkWidget *toolbar;
  private GtkWidget *message_view;
  private GtkWidget *statusbar;

  private GtkUIManager *ui_manager unrefwith g_object_unref;
  private GtkActionGroup *action_group unrefwith g_object_unref;

  private EggToolbarsModel *toolbars_model unrefwith g_object_unref;
  private unsigned int toolbars_model_save_idle_id;

  private unsigned int help_cid;
  private unsigned int count_cid;

  private GtkWidget *leave_fullscreen_popup;
  private gboolean leave_fullscreen_popup_visible;
  private unsigned int leave_fullscreen_timeout_id;

  private GtkWidget *edit_toolbars_dialog;
  private GtkWidget *edit_toolbars_editor;

  init (self)
  {
    GtkWidget *scrolled;
    GtkWidget *vbox;

    self_create_ui_manager(self);
    self_create_toolbars_model(self, TRUE);

    selfp->menubar = gtk_ui_manager_get_widget(selfp->ui_manager, "/menubar");
    selfp->toolbar = egg_editable_toolbar_new_with_model(selfp->ui_manager, selfp->toolbars_model);

    scrolled = gtk_scrolled_window_new(NULL, NULL);
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled),
				   GTK_POLICY_AUTOMATIC,
				   GTK_POLICY_AUTOMATIC);

    selfp->message_view = mn_message_view_new(FALSE, TRUE);
    gtk_widget_set_name(selfp->message_view, "mn-message-view");
    gtk_container_set_border_width(GTK_CONTAINER(selfp->message_view), 12);
    gtk_container_add(GTK_CONTAINER(scrolled), selfp->message_view);

    selfp->statusbar = gtk_statusbar_new();

    vbox = gtk_vbox_new(FALSE, 0);
    gtk_box_pack_start(GTK_BOX(vbox), selfp->menubar, FALSE, FALSE, 0);
    gtk_box_pack_start(GTK_BOX(vbox), selfp->toolbar, FALSE, FALSE, 0);
    gtk_box_pack_start(GTK_BOX(vbox), scrolled, TRUE, TRUE, 0);
    gtk_box_pack_start(GTK_BOX(vbox), selfp->statusbar, FALSE, FALSE, 0);
    gtk_widget_show_all(vbox);
    gtk_container_add(GTK_CONTAINER(self), vbox);

    selfp->help_cid = gtk_statusbar_get_context_id(GTK_STATUSBAR(selfp->statusbar), _("Help messages"));
    selfp->count_cid = gtk_statusbar_get_context_id(GTK_STATUSBAR(selfp->statusbar), _("Count messages"));

    mn_conf_link(self, MN_CONF_MAIN_WINDOW_DIMENSIONS,
		 GET_ACTION("ViewToolbars"), MN_CONF_MAIN_WINDOW_VIEW_TOOLBARS,
		 GET_ACTION("ViewStatusbar"), MN_CONF_MAIN_WINDOW_VIEW_STATUSBAR,
		 GET_ACTION("ViewToolbarsStyleDesktopDefault"), MN_CONF_MAIN_WINDOW_TOOLBARS_STYLE, MN_TYPE_TOOLBAR_STYLE,
		 NULL);

    self_update_toolbars_visibility(self);
    self_update_statusbar_visibility(self);

    g_signal_connect_swapped(GET_ACTION("ViewToolbars"), "toggled", G_CALLBACK(self_update_toolbars_visibility), self);
    g_signal_connect_swapped(GET_ACTION("ViewStatusbar"), "toggled", G_CALLBACK(self_update_statusbar_visibility), self);

    self_update_messages(self);
    self_update_sensitivity(self);

    mn_conf_notification_add(self,
			     MN_CONF_COMMANDS_MAIL_READER_NAMESPACE,
			     self_notify_mail_reader_cb,
			     self);
    mn_g_object_connect(self,
			mn_shell->mailboxes,
			"swapped-signal::notify::must-poll", self_update_sensitivity, self,
			"swapped-signal::messages-changed", self_update_messages, self,
			NULL);
    g_signal_connect(self, "window-state-event", G_CALLBACK(self_window_state_event_h), NULL);

    gtk_widget_grab_focus(selfp->message_view);
  }

  override (G:Object) void
    dispose (GObject *object)
  {
    Self *self = SELF(object);

    mn_source_clear(&selfp->toolbars_model_save_idle_id);

    if (FULLSCREEN)
      self_unfullscreen(self);

    PARENT_HANDLER(object);
  }

  private void
    create_ui_manager (self)
  {
    static GtkActionEntry menu_entries[] = {
      /* Toplevel */
      { "Mail", NULL, N_("_Mail") },
      { "Edit", NULL, N_("_Edit") },
      { "View", NULL, N_("_View") },
      { "Help", NULL, N_("_Help") },

      /* Mail menu */
      {
	"MailMailReader",
	MN_STOCK_MAIL_READER,
	N_("_Mail Reader"),
	"<control>M",
	N_("Launch the mail reader"),
	G_CALLBACK(self_mail_reader_activate_h)
      },
      {
	"MailUpdate",
	GTK_STOCK_REFRESH,
	N_("_Update"),
	"<control>R",		/* Reload */
	N_("Update the mail status"),
	G_CALLBACK(self_update_activate_h)
      },
      {
	"MailClose",
	GTK_STOCK_CLOSE,
	N_("_Close"),
	"<control>W",
	N_("Close this window"),
	G_CALLBACK(self_close_activate_h)
      },
      {
	"MailQuit",
	GTK_STOCK_QUIT,
	N_("_Quit"),
	"<control>Q",
	N_("Quit Mail Notification"),
	G_CALLBACK(self_quit_activate_h)
      },

      /* Edit menu */
      {
	"EditToolbars",
	NULL,
	N_("_Toolbars"),
	NULL,
	N_("Customize the toolbars"),
	G_CALLBACK(self_edit_toolbars_activate_h)
      },
      {
	"EditPreferences",
	GTK_STOCK_PREFERENCES,
	N_("_Preferences"),
	NULL,
	N_("Configure Mail Notification"),
	G_CALLBACK(self_preferences_activate_h)
      },

      /* View menu */
      {
	"ViewToolbarsStyle",
	NULL,
	N_("Toolbars Styl_e"),
	NULL,
	N_("Customize the toolbars style"),
	NULL
      },

      /* Help menu */
      {
	"HelpContents",
	GTK_STOCK_HELP,
	N_("_Contents"),
	"F1",
	N_("Display help"),
	G_CALLBACK(self_help_contents_activate_h)
      },
      {
	"HelpAbout",
	GTK_STOCK_ABOUT,
	N_("_About"),
	NULL,
	N_("Display credits"),
	G_CALLBACK(self_about_activate_h)
      }
    };

    static GtkToggleActionEntry toggle_entries[] = {
      /* View menu */
      {
	"ViewToolbars",
	NULL,
	N_("_Toolbars"),
	NULL,
	N_("Show or hide the toolbars"),
	NULL,
	FALSE
      },
      {
	"ViewStatusbar",
	NULL,
	N_("_Statusbar"),
	NULL,
	N_("Show or hide the statusbar"),
	NULL,
	FALSE
      }
    };

    static GtkRadioActionEntry toolbars_style_entries[] = {
      /* View menu */
      {
	"ViewToolbarsStyleDesktopDefault",
	NULL,
	N_("_Desktop Default"),
	NULL,
	N_("Set the toolbars style to the desktop default setting"),
	MN_TOOLBAR_STYLE_DESKTOP_DEFAULT
      },
      {
	"ViewToolbarsStyleIconsOnly",
	NULL,
	N_("I_cons Only"),
	NULL,
	N_("Only display the toolbars icons"),
	MN_TOOLBAR_STYLE_ICONS
      },
      {
	"ViewToolbarsStyleTextOnly",
	NULL,
	N_("_Text Only"),
	NULL,
	N_("Only display the toolbars text"),
	MN_TOOLBAR_STYLE_TEXT
      },
      {
	"ViewToolbarsStyleTextBelowIcons",
	NULL,
	N_("Text Belo_w Icons"),
	NULL,
	N_("Display the toolbars text below the icons"),
	MN_TOOLBAR_STYLE_BOTH
      },
      {
	"ViewToolbarsStyleTextBesideIcons",
	NULL,
	N_("Text Be_side Icons"),
	NULL,
	N_("Display the toolbars text beside the icons"),
	MN_TOOLBAR_STYLE_BOTH_HORIZ
      }
    };

    GError *err = NULL;
    GtkAccelGroup *accel_group;

    g_return_if_fail(selfp->ui_manager == NULL);

    selfp->ui_manager = gtk_ui_manager_new();

    g_object_connect(selfp->ui_manager,
		     "swapped-signal::connect-proxy", self_ui_manager_connect_proxy_h, self,
		     "swapped-signal::disconnect-proxy", self_ui_manager_disconnect_proxy_h, self,
		     NULL);

    selfp->action_group = gtk_action_group_new("MainWindowActions");
    gtk_action_group_set_translation_domain(selfp->action_group, NULL);
    
    gtk_action_group_add_actions(selfp->action_group,
				 menu_entries,
				 G_N_ELEMENTS(menu_entries),
				 self);
    gtk_action_group_add_toggle_actions(selfp->action_group,
					toggle_entries,
					G_N_ELEMENTS(toggle_entries),
					self);
    gtk_action_group_add_radio_actions(selfp->action_group,
				       toolbars_style_entries,
				       G_N_ELEMENTS(toolbars_style_entries),
				       -1,
				       G_CALLBACK(self_update_toolbars_style_changed_h),
				       self);
    gtk_ui_manager_insert_action_group(selfp->ui_manager, selfp->action_group, 0);

    g_object_set(G_OBJECT(GET_ACTION("MailMailReader")),
		 "is-important", TRUE,
		 NULL);

    if (! gtk_ui_manager_add_ui_from_file(selfp->ui_manager, MN_INTERFACE_FILE("menus.xml"), &err))
      {
	g_critical(_("unable to load menus.xml: %s"), err->message);
	g_error_free(err);
      }

    accel_group = gtk_ui_manager_get_accel_group(selfp->ui_manager);
    gtk_window_add_accel_group(GTK_WINDOW(self), accel_group);

    /*
     * ~/.gnome2/accels/mail-notification is automatically loaded by
     * the libgnomeui module, we just need to save it ourselves.
     */
    g_signal_connect(accel_group, "accel-changed", G_CALLBACK(gnome_accelerators_sync), NULL);
  }

  private void
    create_toolbars_model (self, gboolean use_dot_file)
  {
    gboolean load_default_toolbars = TRUE;

    if (selfp->toolbars_model)
      g_object_unref(selfp->toolbars_model);

    selfp->toolbars_model = egg_toolbars_model_new();

    g_object_connect(selfp->toolbars_model,
		     "swapped-signal-after::item-added", self_toolbars_model_save_changes, self,
		     "swapped-signal-after::item-removed", self_toolbars_model_save_changes, self,
		     "swapped-signal-after::toolbar-added", self_toolbars_model_update_flags_and_save_changes, self,
		     "swapped-signal-after::toolbar-removed", self_toolbars_model_update_flags_and_save_changes, self,
		     NULL);

    if (use_dot_file)
      {
	char *filename;

	filename = g_build_filename(mn_conf_dot_dir, "toolbars.xml", NULL);
	load_default_toolbars = ! egg_toolbars_model_load(selfp->toolbars_model, filename);
	g_free(filename);
      }

    if (load_default_toolbars)
      {
	if (! egg_toolbars_model_load(selfp->toolbars_model, MN_INTERFACE_FILE("toolbars.xml")))
	  g_critical(_("unable to load toolbars.xml"));
      }
  
  if (egg_toolbars_model_n_toolbars(selfp->toolbars_model) < 1)
    egg_toolbars_model_add_toolbar(selfp->toolbars_model, 0, "DefaultToolbar");

  if (selfp->toolbar)
    egg_editable_toolbar_set_model(EGG_EDITABLE_TOOLBAR(selfp->toolbar), selfp->toolbars_model);
  }
  
  private void
    update_toolbars_visibility (self)
  {
    g_object_set(G_OBJECT(selfp->toolbar), "visible", gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(GET_ACTION("ViewToolbars"))), NULL);
  }

  private void
    update_statusbar_visibility (self)
  {
    g_object_set(G_OBJECT(selfp->statusbar), "visible", ! FULLSCREEN && gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(GET_ACTION("ViewStatusbar"))), NULL);
  }

  private void
    notify_mail_reader_cb (GConfClient *client,
			   unsigned int cnxn_id,
			   GConfEntry *entry,
			   gpointer user_data)
  {
    Self *self = user_data;

    GDK_THREADS_ENTER();
    self_update_sensitivity(self);
    GDK_THREADS_LEAVE();
  }

  private void
    update_messages (self)
  {
    GSList *messages;
    int count;

    messages = mn_mailboxes_get_messages(mn_shell->mailboxes);
    count = g_slist_length(messages);

    mn_message_view_set_messages(MN_MESSAGE_VIEW(selfp->message_view), messages);
    mn_g_object_slist_free(messages);

    if (count > 0)
      {
	char *status;
	
	status = g_strdup_printf(ngettext("%i new message", "%i new messages", count), count);
	STATUS_PUSH(selfp->count_cid, status);
	g_free(status);
      }
    else
      STATUS_POP(selfp->count_cid);
  }

  private void
    update_sensitivity (self)
  {
    gtk_action_set_sensitive(GET_ACTION("MailMailReader"), mn_conf_has_command(MN_CONF_COMMANDS_MAIL_READER_NAMESPACE));
    gtk_action_set_sensitive(GET_ACTION("MailUpdate"), mn_mailboxes_get_must_poll(mn_shell->mailboxes));
  }

  private void
    ui_manager_connect_proxy_h (self,
				GtkAction *action,
				GtkWidget *proxy,
				GtkUIManager *manager)
  {
    if (GTK_IS_MENU_ITEM(proxy))
      g_object_connect(proxy,
		       "swapped-signal::select", self_menu_item_select_h, self,
		       "swapped-signal::deselect", self_menu_item_deselect_h, self,
		       NULL);
  }

  private void
    ui_manager_disconnect_proxy_h (self,
				   GtkAction *action,
				   GtkWidget *proxy,
				   GtkUIManager *manager)
  {
    if (GTK_IS_MENU_ITEM(proxy))
      g_object_disconnect(proxy,
			  "any-signal", self_menu_item_select_h, self,
			  "any-signal", self_menu_item_deselect_h, self,
			  NULL);
  }

  private void
    menu_item_select_h (self, GtkMenuItem *item)
  {
    GtkAction *action;
    char *tooltip = NULL;

    action = g_object_get_data(G_OBJECT(item), "gtk-action");
    g_return_if_fail(action != NULL);
  
    g_object_get(G_OBJECT(action), "tooltip", &tooltip, NULL);
    if (tooltip)
      {
	STATUS_PUSH(selfp->help_cid, tooltip);
	g_free(tooltip);
      }
  }

  private void
    menu_item_deselect_h (self, GtkMenuItem *item)
  {
    STATUS_POP(selfp->help_cid);
  }

  private gboolean
    window_state_event_h (self, GdkEventWindowState *event, gpointer user_data)
  {
    if (event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN)
      {
	if (event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN)
	  self_fullscreen(self);
	else
	  self_unfullscreen(self);
      }
    
    return FALSE;		/* propagate event */
  }
  
  private void
    update_toolbars_style_changed_h (GtkRadioAction *action,
				     GtkRadioAction *current,
				     Self *self)
  {
    self_update_toolbars_style(self);
  }
  
  private void
    update_toolbars_style (self)
  {
    MNToolbarStyle style;
    EggTbModelFlags flag;
    int n_toolbars;
    int i;

    style = gtk_radio_action_get_current_value(GTK_RADIO_ACTION(GET_ACTION("ViewToolbarsStyleDesktopDefault")));
    if (style == MN_TOOLBAR_STYLE_DESKTOP_DEFAULT)
      g_object_get(gtk_widget_get_settings(selfp->toolbar), "gtk-toolbar-style", &style, NULL);

    if (FULLSCREEN && style == MN_TOOLBAR_STYLE_BOTH)
      style = MN_TOOLBAR_STYLE_ICONS;

    switch (style)
      {
      case MN_TOOLBAR_STYLE_ICONS:	flag = EGG_TB_MODEL_ICONS; break;
      case MN_TOOLBAR_STYLE_TEXT:	flag = EGG_TB_MODEL_TEXT; break;
      case MN_TOOLBAR_STYLE_BOTH:	flag = EGG_TB_MODEL_BOTH; break;
      case MN_TOOLBAR_STYLE_BOTH_HORIZ:	flag = EGG_TB_MODEL_BOTH_HORIZ; break;
      default:				g_assert_not_reached();
      }
    
    n_toolbars = egg_toolbars_model_n_toolbars(selfp->toolbars_model);

    for (i = 0; i < n_toolbars; i++)
      {
	EggTbModelFlags flags;

	flags = egg_toolbars_model_get_flags(selfp->toolbars_model, i);
	flags &= ~ (EGG_TB_MODEL_ICONS
		    | EGG_TB_MODEL_TEXT
		    | EGG_TB_MODEL_BOTH
		    | EGG_TB_MODEL_BOTH_HORIZ);
	flags |= flag;
	egg_toolbars_model_set_flags(selfp->toolbars_model, i, flags);
      }
  }

  private void
    toolbars_model_save_changes (self)
  {
    if (! selfp->toolbars_model_save_idle_id)
      selfp->toolbars_model_save_idle_id = g_idle_add((GSourceFunc) self_toolbars_model_save_changes_cb, self);
  }

  private gboolean
    toolbars_model_save_changes_cb (self)
  {
    char *filename;

    GDK_THREADS_ENTER();

    filename = g_build_filename(mn_conf_dot_dir, "toolbars.xml", NULL);
    egg_toolbars_model_save(selfp->toolbars_model, filename, "1.0");
    g_free(filename);

    GDK_THREADS_LEAVE();

    selfp->toolbars_model_save_idle_id = 0;
    return FALSE;		/* remove */
  }

  private void
    toolbars_model_update_flags_and_save_changes (self)
  {
    int i;
    int n_toolbars;
    EggTbModelFlags flag = EGG_TB_MODEL_ACCEPT_ITEMS_ONLY;

    n_toolbars = egg_toolbars_model_n_toolbars(selfp->toolbars_model);
  
    if (n_toolbars <= 1)
      flag |= EGG_TB_MODEL_NOT_REMOVABLE;

    for (i = 0; i < n_toolbars; i++)
      {
	EggTbModelFlags flags;
	
	flags = egg_toolbars_model_get_flags(selfp->toolbars_model, i);
	flags &= ~EGG_TB_MODEL_NOT_REMOVABLE;
	flags |= flag;
	egg_toolbars_model_set_flags(selfp->toolbars_model, i, flags);
      }

    self_toolbars_model_save_changes(self);
  }

  private void
    mail_reader_activate_h (GtkAction *action, Self *self)
  {
    mn_execute_command(MN_CONF_COMMANDS_MAIL_READER_COMMAND);
  }

  private void
    update_activate_h (GtkAction *action, Self *self)
  {
    mn_mailboxes_check(mn_shell->mailboxes);
  }

  private void
    close_activate_h (GtkAction *action, Self *self)
  {
    gtk_widget_destroy(GTK_WIDGET(self));
  }
  
  private void
    quit_activate_h (GtkAction *action, Self *self)
  {
    g_object_unref(mn_shell);
  }

  private void
    edit_toolbars_activate_h (GtkAction *action, Self *self)
  {
    if (selfp->edit_toolbars_dialog)
      {
	gtk_window_present(GTK_WINDOW(selfp->edit_toolbars_dialog));
	return;
      }
  
    mn_create_interface(MN_INTERFACE_FILE("edit-toolbars-dialog.glade"),
			"dialog", &selfp->edit_toolbars_dialog,
			NULL);

    eel_add_weak_pointer(&selfp->edit_toolbars_dialog);
    g_object_weak_ref(G_OBJECT(selfp->edit_toolbars_dialog), (GWeakNotify) self_edit_toolbars_weak_notify_cb, self);
    
    gtk_window_set_transient_for(GTK_WINDOW(selfp->edit_toolbars_dialog), GTK_WINDOW(self));

    self_edit_toolbars_create_editor(self);
    egg_editable_toolbar_set_edit_mode(EGG_EDITABLE_TOOLBAR(selfp->toolbar), TRUE);

    mn_conf_link(selfp->edit_toolbars_dialog, MN_CONF_MAIN_WINDOW_EDIT_TOOLBARS_DIALOG, NULL);

    g_signal_connect_swapped(selfp->edit_toolbars_dialog, "response", G_CALLBACK(self_edit_toolbars_response_h), self);

    gtk_widget_show(selfp->edit_toolbars_dialog);
  }

  private void
    edit_toolbars_response_h (self, int response, GtkDialog *dialog)
  {
    switch (response)
      {
      case GTK_RESPONSE_HELP:
	mn_display_help(GTK_WINDOW(dialog), "main-window-edit-toolbars");
	break;

      case 1:			/* use default */
	/* recreate the model, discarding the dot file */
	self_create_toolbars_model(self, FALSE);
	/* and recreate the editor, since the model has changed */
	self_edit_toolbars_create_editor(self);
	break;

      case 2:			/* add toolbar */
	egg_toolbars_model_add_toolbar(selfp->toolbars_model, -1, "UserCreated");
	break;
	
      case GTK_RESPONSE_CLOSE:
	gtk_widget_destroy(GTK_WIDGET(dialog));
	break;
      }
  }
  
  private void
    edit_toolbars_create_editor (self)
  {
    g_return_if_fail(selfp->edit_toolbars_dialog != NULL);

    if (selfp->edit_toolbars_editor)
      gtk_widget_destroy(selfp->edit_toolbars_editor);

    selfp->edit_toolbars_editor = egg_toolbar_editor_new(selfp->ui_manager, selfp->toolbars_model);
    eel_add_weak_pointer(&selfp->edit_toolbars_editor);

    gtk_container_set_border_width(GTK_CONTAINER(selfp->edit_toolbars_editor), 5);
    gtk_box_set_spacing(GTK_BOX(selfp->edit_toolbars_editor), 6);
  
    egg_toolbar_editor_load_actions(EGG_TOOLBAR_EDITOR(selfp->edit_toolbars_editor), MN_INTERFACE_FILE("toolbars.xml"));

    gtk_container_add(GTK_CONTAINER(GTK_DIALOG(selfp->edit_toolbars_dialog)->vbox), selfp->edit_toolbars_editor);
    gtk_widget_show(selfp->edit_toolbars_editor);
  }

  private void
    edit_toolbars_weak_notify_cb (self, GObject *former_object)
  {
    egg_editable_toolbar_set_edit_mode(EGG_EDITABLE_TOOLBAR(selfp->toolbar), FALSE);
  }

  private void
    preferences_activate_h (GtkAction *action, Self *self)
  {
    mn_shell_display_properties_dialog(mn_shell, GTK_WINDOW(self));
  }

  private void
    help_contents_activate_h (GtkAction *action, Self *self)
  {
    mn_display_help(GTK_WINDOW(self), "main-window");
  }

  private void
    about_activate_h (GtkAction *action, Self *self)
  {
    mn_shell_display_about_dialog(mn_shell, GTK_WINDOW(self));
  }

  private void
    fullscreen (self)
  {
    GtkWidget *button;

    selfp->leave_fullscreen_popup = gtk_window_new(GTK_WINDOW_POPUP);
    eel_add_weak_pointer(&selfp->leave_fullscreen_popup);

    button = gtk_button_new_from_stock(MN_STOCK_LEAVE_FULLSCREEN);
    gtk_container_add(GTK_CONTAINER(selfp->leave_fullscreen_popup), button);
    gtk_widget_show(button);

    g_signal_connect_swapped(button, "clicked", G_CALLBACK(gtk_window_unfullscreen), self);

    gtk_widget_hide(selfp->menubar);
    self_update_toolbars_style(self);
    self_update_statusbar_visibility(self);

    selfp->leave_fullscreen_popup_visible = TRUE;
    self_update_leave_fullscreen_popup_position(self);
    gtk_widget_show(selfp->leave_fullscreen_popup);

    g_signal_connect_swapped(gdk_screen_get_default(),
			     "size-changed",
			     G_CALLBACK(self_update_leave_fullscreen_popup_position),
			     self);
    g_signal_connect(self,
		     "key-press-event",
		     G_CALLBACK(self_fullscreen_key_press_event_h),
		     NULL);

    g_object_connect(selfp->leave_fullscreen_popup,
		     "swapped-signal::enter-notify-event", self_leave_fullscreen_enter_notify_event_h, self,
		     "swapped-signal::leave-notify-event", self_leave_fullscreen_leave_notify_event_h, self,
		     NULL);

    selfp->leave_fullscreen_timeout_id = g_timeout_add(5000, (GSourceFunc) self_leave_fullscreen_timeout_cb, self);
  }

  private void
    unfullscreen (self)
  {
    g_signal_handlers_disconnect_by_func(gdk_screen_get_default(), self_update_leave_fullscreen_popup_position, self);

    mn_source_clear(&selfp->leave_fullscreen_timeout_id);
    gtk_widget_destroy(selfp->leave_fullscreen_popup);

    g_signal_handlers_disconnect_by_func(self, self_fullscreen_key_press_event_h, NULL);
      
    gtk_widget_show(selfp->menubar);
    self_update_toolbars_style(self);
    self_update_statusbar_visibility(self);
  }

  private gboolean
    leave_fullscreen_timeout_cb (self)
  {
    selfp->leave_fullscreen_popup_visible = FALSE;

    GDK_THREADS_ENTER();
    self_update_leave_fullscreen_popup_position(self);
    GDK_THREADS_LEAVE();
    
    selfp->leave_fullscreen_timeout_id = 0;
    return FALSE;		/* remove timeout */
  }

  private gboolean
    leave_fullscreen_enter_notify_event_h (self,
					   GdkEventCrossing *event,
					   GtkWidget *widget)
  {
    mn_source_clear(&selfp->leave_fullscreen_timeout_id);
    selfp->leave_fullscreen_popup_visible = TRUE;
    self_update_leave_fullscreen_popup_position(self);

    return FALSE;		/* propagate event */
  }

  private gboolean
    leave_fullscreen_leave_notify_event_h (self,
					   GdkEventCrossing *event,
					   GtkWidget *widget)
  {
    mn_source_clear(&selfp->leave_fullscreen_timeout_id);
    selfp->leave_fullscreen_timeout_id = g_timeout_add(5000, (GSourceFunc) self_leave_fullscreen_timeout_cb, self);

    return FALSE;		/* propagate event */
  }
  
  private void
    update_leave_fullscreen_popup_position (self)
  {
    GdkScreen *screen;
    int monitor_num;
    GdkRectangle screen_rect;
    int popup_width;
    int popup_height;
    int y;

    g_return_if_fail(selfp->leave_fullscreen_popup != NULL);

    screen = gdk_screen_get_default();
    monitor_num = gdk_screen_get_monitor_at_window(screen, GTK_WIDGET(self)->window);
    gdk_screen_get_monitor_geometry(screen, monitor_num, &screen_rect);
    gtk_window_get_size(GTK_WINDOW(selfp->leave_fullscreen_popup), &popup_width, &popup_height);

    y = screen_rect.y;
    if (! selfp->leave_fullscreen_popup_visible)
      y -= popup_height - 2;

    gtk_window_move(GTK_WINDOW(selfp->leave_fullscreen_popup), screen_rect.width - popup_width, y);
  }

  private gboolean
    fullscreen_key_press_event_h (self, GdkEventKey *event, gpointer user_data)
  {
    unsigned int modifiers = gtk_accelerator_get_default_mod_mask();

    if (event->keyval == GDK_Escape && (event->state & modifiers) == 0)
      {
	gtk_window_unfullscreen(GTK_WINDOW(self));
	return TRUE;		/* do not propagate event */
      }
    else if (event->keyval == GDK_F10 && (event->state & modifiers) == 0)
      {
	g_signal_connect_swapped(selfp->menubar, "deactivate", G_CALLBACK(self_fullscreen_menubar_deactivate_h), self);

	gtk_widget_show(selfp->menubar);
	gtk_menu_shell_select_first(GTK_MENU_SHELL(selfp->menubar), FALSE);

	return TRUE;		/* do not propagate event */
      }
    else
      return FALSE;		/* propagate event */
  }

  private void
    fullscreen_menubar_deactivate_h (self, GtkMenuShell *menushell)
  {
    g_signal_handlers_disconnect_by_func(selfp->menubar, G_CALLBACK(self_fullscreen_menubar_deactivate_h), self);
    gtk_menu_shell_deselect(menushell);
    gtk_widget_hide(selfp->menubar);
  }
}
