/* 
 * Copyright (c) 2004 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

requires 2.0.10

%headertop{
#include <gtk/gtk.h>
%}
%{
#include "config.h"
#include <glib/gi18n-lib.h>
#include "mn-mailbox-properties.h"
#include "mn-mailbox-properties-util.h"
#include "mn-auth-combo-box.h"
#include "mn-util.h"
%}

class MN:PI:Mailbox:Properties from Gtk:VBox (interface MN:Mailbox:Properties)
{
  classwide const char *label;
  classwide int default_port[2]; /* 0: standard, 1: SSL/TLS */

  property BOOLEAN complete (override)
    get {};			/* dummy, implemented by subclasses */
  
  property STRING label (override)
    get { g_value_set_string(VAL, SELF_GET_CLASS(self)->label); };

  protected GtkSizeGroup *size_group unrefwith g_object_unref;
  property OBJECT size_group (override, link);

  protected GtkWidget *hostname_entry;
  protected GtkWidget *username_entry;
  protected GtkWidget *password_entry;
  protected GtkTooltips *tooltips = {mn_tooltips_new()} unrefwith g_object_unref;
  protected GtkWidget *details_vbox;
  protected GtkSizeGroup *details_size_group;
  protected GtkWidget *conn_radio[3];
  protected GtkWidget *port_spin[3];
  protected GtkWidget *auth_combo;

  override (G:Object) GObject *
    constructor (GType type, guint n_construct_properties, GObjectConstructParam *construct_params)
  {
    GObject *object;
    Self *self;
    GtkWidget *label1;
    GtkWidget *label2;
    GtkWidget *expander;
    GtkSizeGroup *radio_size_group;
    int i;

    object = PARENT_HANDLER(type, n_construct_properties, construct_params);
    self = SELF(object);

    gtk_box_set_spacing(GTK_BOX(self), 6);
    
    self->details_size_group = gtk_size_group_new(GTK_SIZE_GROUP_NONE);

    mn_mailbox_properties_field_new(GTK_VBOX(self),
				    _("_Hostname:"),
				    &label1,
				    &self->hostname_entry);

    gtk_size_group_add_widget(self->size_group, label1);
    gtk_size_group_add_widget(self->details_size_group, label1);

    mn_mailbox_properties_credentials_new(GTK_VBOX(self),
					  &label1,
					  &self->username_entry,
					  &label2,
					  &self->password_entry);

    gtk_size_group_add_widget(self->size_group, label1);
    gtk_size_group_add_widget(self->details_size_group, label1);
    gtk_size_group_add_widget(self->size_group, label2);
    gtk_size_group_add_widget(self->details_size_group, label2);

    expander = gtk_expander_new_with_mnemonic(_("_Details"));
    gtk_expander_set_spacing(GTK_EXPANDER(expander), 6);

    self->details_vbox = gtk_vbox_new(FALSE, 6);
    gtk_container_add(GTK_CONTAINER(expander), self->details_vbox);
    
    gtk_box_pack_start(GTK_BOX(self), expander, FALSE, FALSE, 0);
    gtk_widget_show_all(expander);
    
    radio_size_group = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);

    mn_mailbox_properties_connection_type_new(GTK_VBOX(self->details_vbox),
					      _("sta_ndard"),
					      SELF_GET_CLASS(self)->default_port[0],
					      NULL,
					      &label1,
					      &self->conn_radio[0],
					      &self->port_spin[0]);
    gtk_size_group_add_widget(self->details_size_group, label1);
    gtk_size_group_add_widget(radio_size_group, self->conn_radio[0]);

    mn_mailbox_properties_connection_type_new(GTK_VBOX(self->details_vbox),
					      _("_in-band SSL/TLS"),
					      SELF_GET_CLASS(self)->default_port[0],
					      GTK_RADIO_BUTTON(self->conn_radio[0]),
					      &label1,
					      &self->conn_radio[1],
					      &self->port_spin[1]);
    gtk_size_group_add_widget(self->details_size_group, label1);
    gtk_size_group_add_widget(radio_size_group, self->conn_radio[1]);

    mn_mailbox_properties_connection_type_new(GTK_VBOX(self->details_vbox),
					      _("SSL/TLS on sepa_rate port"),
					      SELF_GET_CLASS(self)->default_port[1],
					      GTK_RADIO_BUTTON(self->conn_radio[0]),
					      &label1,
					      &self->conn_radio[2],
					      &self->port_spin[2]);
    gtk_size_group_add_widget(self->details_size_group, label1);
    gtk_size_group_add_widget(radio_size_group, self->conn_radio[2]);

    g_object_unref(radio_size_group);
    
#ifndef WITH_SSL
    gtk_widget_set_sensitive(self->conn_radio[1], FALSE);
    gtk_widget_set_sensitive(self->conn_radio[2], FALSE);
#endif

    /* by default, standard is enabled */
    gtk_widget_set_sensitive(self->port_spin[1], FALSE);
    gtk_widget_set_sensitive(self->port_spin[2], FALSE);

    mn_mailbox_properties_authentication_new(GTK_VBOX(self->details_vbox),
					     &label1,
					     &self->auth_combo);
    gtk_size_group_add_widget(self->details_size_group, label1);

    mn_mailbox_properties_link_entries(GTK_ENTRY(self->hostname_entry),
				       GTK_ENTRY(self->username_entry),
				       GTK_ENTRY(self->password_entry),
				       NULL);

    g_signal_connect(expander, "notify::expanded", G_CALLBACK(self_notify_expanded_h), self);

    for (i = 0; i < 3; i++)
      g_signal_connect(self->conn_radio[i], "toggled", G_CALLBACK(self_radio_toggled_h), self);
    
    g_signal_connect(self->hostname_entry, "changed", G_CALLBACK(self_entry_changed_h), self);
    g_signal_connect(self->username_entry, "changed", G_CALLBACK(self_entry_changed_h), self);
    g_signal_connect(self->password_entry, "changed", G_CALLBACK(self_entry_changed_h), self);

    return object;
  }

  private void
    notify_expanded_h (G:Object *object (check null type),
		       GParamSpec *pspec (check null),
		       gpointer user_data (check null))
  {
    Self *self = user_data;

    gtk_size_group_set_mode(self->details_size_group,
			    gtk_expander_get_expanded(GTK_EXPANDER(object))
			    ? GTK_SIZE_GROUP_HORIZONTAL
			    : GTK_SIZE_GROUP_NONE);
  }
  
  protected void
    entry_changed_h (Gtk:Editable *editable (check null type),
		     gpointer user_data (check null))
  {
    Self *self = user_data;
    g_object_notify(G_OBJECT(self), "complete");
  }

  private void
    radio_toggled_h (Gtk:Toggle:Button *togglebutton (check null type),
		     gpointer user_data (check null))
  {
    Self *self = user_data;
    int i;

    for (i = 0; i < 3; i++)
      gtk_widget_set_sensitive(self->port_spin[i], GTK_WIDGET_SENSITIVE(self->conn_radio[i]) && gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(self->conn_radio[i])));

    g_object_notify(G_OBJECT(self), "complete");
  }

  public void
    set_contents (self,
		  gboolean ssl,
		  gboolean inband_ssl,
		  const char *username (check null),
		  const char *password (check null),
		  const char *authmech,
		  const char *hostname (check null),
		  int port (check >= 0 <= 0xFFFF))
  {
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->conn_radio[ssl ? 2 : (inband_ssl ? 1 : 0)]), TRUE);
    gtk_entry_set_text(GTK_ENTRY(self->username_entry), username);
    gtk_entry_set_text(GTK_ENTRY(self->password_entry), password);
    mn_auth_combo_box_set_active_mechanism(MN_AUTH_COMBO_BOX(self->auth_combo), (char *) authmech);
    gtk_entry_set_text(GTK_ENTRY(self->hostname_entry), hostname);
    gtk_spin_button_set_value(GTK_SPIN_BUTTON(self->port_spin[ssl ? 2 : (inband_ssl ? 1 : 0)]), port);
  }

  public void
    get_contents (self,
		  gboolean *ssl,
		  gboolean *inband_ssl,
		  const char **username,
		  const char **password,
		  char **authmech,
		  const char **hostname,
		  int *port)
  {
    gboolean _ssl;
    gboolean _inband_ssl;

    _ssl = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(self->conn_radio[2]));
    _inband_ssl = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(self->conn_radio[1]));

    if (ssl)
      *ssl = _ssl;
    if (inband_ssl)
      *inband_ssl = _inband_ssl;
    if (username)
      *username = gtk_entry_get_text(GTK_ENTRY(self->username_entry));
    if (password)
      *password = gtk_entry_get_text(GTK_ENTRY(self->password_entry));
    if (authmech)
      *authmech = mn_auth_combo_box_get_active_mechanism(MN_AUTH_COMBO_BOX(self->auth_combo));
    if (hostname)
      *hostname = gtk_entry_get_text(GTK_ENTRY(self->hostname_entry));
    if (port)
      *port = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(self->port_spin[_ssl ? 2 : (_inband_ssl ? 1 : 0)]));
  }
}
