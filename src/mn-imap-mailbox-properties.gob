/* 
 * Copyright (c) 2004 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

%headertop{
#include "mn-pi-mailbox-properties.h"
%}
%{
#include "config.h"
#include <glib/gi18n-lib.h>
#include "mn-mailbox-properties.h"
#include "mn-mailbox-properties-util.h"
#include "mn-pi-mailbox-properties-private.h"
#include "mn-auth-combo-box.h"
#include "mn-util.h"
%}

class MN:IMAP:Mailbox:Properties from MN:PI:Mailbox:Properties (interface MN:Mailbox:Properties)
{
  property BOOLEAN complete (override)
    get
    {
      MNPIMailboxProperties *pi = MN_PI_MAILBOX_PROPERTIES(self);
      gboolean complete;
      const char *username;
      const char *password;
      const char *hostname;
      gboolean other_active;
      const char *mailbox;
      
      mn_pi_mailbox_properties_get_contents(pi,
					    NULL,
					    NULL,
					    &username,
					    &password,
					    NULL,
					    &hostname,
					    NULL);
      
      other_active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(selfp->other_radio));
      mailbox = gtk_entry_get_text(GTK_ENTRY(selfp->mailbox_entry));

      complete = *username && *password && *hostname && (! other_active || *mailbox);
#ifndef WITH_SSL
      if (complete)
	complete = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(pi->conn_radio[0]));
#endif /* WITH_SSL */

      g_value_set_boolean(VAL, complete);
    };
  
  private GtkWidget *inbox_radio;
  private GtkWidget *other_radio;
  private GtkWidget *mailbox_entry;

  class_init (class)
  {
    MNPIMailboxPropertiesClass *pi_class = MN_PI_MAILBOX_PROPERTIES_CLASS(class);

    pi_class->label = "IMAP";
    pi_class->default_port[0] = mn_uri_get_default_port("imap");
    pi_class->default_port[1] = mn_uri_get_default_port("imaps");
  }

  override (G:Object) GObject *
    constructor (GType type, guint n_construct_properties, GObjectConstructParam *construct_params)
  {
    GObject *object;
    Self *self;
    MNPIMailboxProperties *pi;
    GtkWidget *hbox;
    GtkWidget *label;
    
    object = PARENT_HANDLER(type, n_construct_properties, construct_params);
    self = SELF(object);
    pi = MN_PI_MAILBOX_PROPERTIES(object);

    label = gtk_label_new(_("Mailbox:"));
    gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);
    gtk_size_group_add_widget(pi->details_size_group, label);

    selfp->inbox_radio = gtk_radio_button_new_with_mnemonic(NULL, _("in_box"));
    
    hbox = gtk_hbox_new(FALSE, 12);
    gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
    gtk_box_pack_start(GTK_BOX(hbox), selfp->inbox_radio, FALSE, FALSE, 0);
    gtk_box_pack_start(GTK_BOX(pi->details_vbox), hbox, FALSE, FALSE, 0);
    gtk_widget_show_all(hbox);

    label = gtk_label_new(NULL);
    gtk_size_group_add_widget(pi->details_size_group, label);

    selfp->other_radio = gtk_radio_button_new_with_mnemonic_from_widget(GTK_RADIO_BUTTON(selfp->inbox_radio), _("oth_er:"));
    selfp->mailbox_entry = gtk_entry_new();
    gtk_widget_set_sensitive(selfp->mailbox_entry, FALSE);
    gtk_entry_set_activates_default(GTK_ENTRY(selfp->mailbox_entry), TRUE);

    hbox = gtk_hbox_new(FALSE, 12);
    gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
    gtk_box_pack_start(GTK_BOX(hbox), selfp->other_radio, FALSE, FALSE, 0);
    gtk_box_pack_start(GTK_BOX(hbox), selfp->mailbox_entry, TRUE, TRUE, 0);
    gtk_box_pack_start(GTK_BOX(pi->details_vbox), hbox, FALSE, FALSE, 0);
    gtk_widget_show_all(hbox);
    
    mn_auth_combo_box_append(MN_AUTH_COMBO_BOX(pi->auth_combo), "+LOGIN", "IMAP LOGIN");

    mn_tooltips_set_tips(pi->tooltips,
			 pi->hostname_entry, _("The hostname or IP address of the IMAP server"),
			 pi->username_entry, _("Your username on the IMAP server"),
			 pi->password_entry, _("Your password on the IMAP server"),
			 pi->port_spin[0], _("The port number of the IMAP server"),
			 pi->port_spin[1], _("The port number of the IMAP server"),
			 selfp->mailbox_entry, _("The mailbox name"),
			 NULL);

    g_signal_connect(G_OBJECT(selfp->inbox_radio), "toggled", G_CALLBACK(self_radio_toggled_h), self);
    g_signal_connect(G_OBJECT(selfp->other_radio), "toggled", G_CALLBACK(self_radio_toggled_h), self);
    g_signal_connect(G_OBJECT(selfp->mailbox_entry), "changed", G_CALLBACK(mn_pi_mailbox_properties_entry_changed_h), self);
    
    return object;
  }
  
  private void
    radio_toggled_h (Gtk:Toggle:Button *togglebutton (check null type),
		     gpointer user_data (check null))
  {
    Self *self = user_data;

    gtk_widget_set_sensitive(selfp->mailbox_entry, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(selfp->other_radio)));
    g_object_notify(G_OBJECT(self), "complete");
  }
  
  interface MN:Mailbox:Properties private gboolean
    set_uri (MN:Mailbox:Properties *properties (check null type),
	     MN:URI *uri (check null type))
  {
    Self *self = SELF(properties);
    
    if (MN_URI_IS_IMAP(uri))
      {
	mn_pi_mailbox_properties_set_contents(MN_PI_MAILBOX_PROPERTIES(properties),
					      MN_URI_IS_SSL(uri),
					      MN_URI_IS_INBAND_SSL(uri),
					      uri->username,
					      uri->password,
					      uri->authmech,
					      uri->hostname,
					      uri->port);
	
	if (! strcmp(uri->path, "INBOX"))
	  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(selfp->inbox_radio), TRUE);
	else
	  {
	    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(selfp->other_radio), TRUE);
	    gtk_entry_set_text(GTK_ENTRY(selfp->mailbox_entry), uri->path);
	  }

	return TRUE;
      }
    else
      return FALSE;
  }

  interface MN:Mailbox:Properties private MNURI *
    get_uri (MN:Mailbox:Properties *properties (check null type))
  {
    Self *self = SELF(properties);
    gboolean ssl;
    gboolean inband_ssl;
    const char *username;
    const char *password;
    char *authmech;
    const char *hostname;
    int port;
    const char *mailbox = NULL;
    MNURI *uri;

    mn_pi_mailbox_properties_get_contents(MN_PI_MAILBOX_PROPERTIES(properties),
					  &ssl,
					  &inband_ssl,
					  &username,
					  &password,
					  &authmech,
					  &hostname,
					  &port);

    mailbox = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(selfp->inbox_radio))
      ? "INBOX"
      : gtk_entry_get_text(GTK_ENTRY(selfp->mailbox_entry));

    uri = mn_uri_new_imap(ssl, inband_ssl, username, password, authmech, hostname, port, mailbox);
    g_free(authmech);

    return uri;
  }
}
