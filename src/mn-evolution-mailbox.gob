/*
 * Mail Notification
 * Copyright (C) 2003-2006 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

requires 2.0.14

%headertop{
#include "mn-reentrant-mailbox.h"
#include "mn-bonobo-unknown.h"
%}

%privateheader{
#include <time.h>
#include "GNOME_MailNotification_Evolution.h"
#include "mn-locked-callback.h"
%}

%{
#include "config.h"
#include <glib/gi18n.h>
#include <libbonobo.h>
#include "mn-evolution.h"
#include "mn-mailbox-private.h"
#include "mn-reentrant-mailbox-private.h"
#include "mn-message.h"
#include "mn-util.h"
#include "mn-stock.h"
#include "mn-evolution-message.h"
#include "mn-evolution-glue-client.h"

static GStaticMutex listeners_mutex = G_STATIC_MUTEX_INIT;
%}

class MN:Evolution:Mailbox from MN:Reentrant:Mailbox
{
  public char *uri destroywith g_free;
  property STRING uri (link, flags = MN_MAILBOX_PARAM_PERMANENT | MN_MAILBOX_PARAM_REQUIRED);

  /*
   * Evolution might not be running when we instantiate the mailbox,
   * so we cache the folder name.
   */
  public char *folder_name destroywith g_free;
  property STRING folder_name (link, flags = MN_MAILBOX_PARAM_PERMANENT | MN_MAILBOX_PARAM_REQUIRED);

  private MNBonoboUnknown *glue;
  private MNLockedBonoboListener *listener;

  private time_t last_browsed;

  class_init (class)
  {
    MN_MAILBOX_CLASS(class)->type = "evolution";

    /*
     * The mailbox is only polled if the folder was not found. Since
     * this is unlikely, and since Evolution is probably running on
     * the local machine, we choose a small default check delay (1
     * minute).
     */
    MN_MAILBOX_CLASS(class)->default_check_delay = 60 * 1;

    bonobo_exception_add_handler_str(ex_GNOME_MailNotification_Evolution_Glue_FolderNotFound, _("folder not found"));
    bonobo_exception_add_handler_str(ex_GNOME_MailNotification_Evolution_Glue_MessageNotFound, _("message not found"));
  }

  init (self)
  {
    mn_mailbox_set_format(MN_MAILBOX(self), "Evolution");
    mn_mailbox_set_stock_id(MN_MAILBOX(self), MN_STOCK_EVOLUTION_MAILBOX);

    /* we receive notifications from Evolution, no need to poll */
    mn_mailbox_set_poll(MN_MAILBOX(self), FALSE);
  }

  override (MN:Mailbox) void
    seal (MNMailbox *mailbox)
  {
    PARENT_HANDLER(mailbox);

    if (! mailbox->runtime_name)
      mailbox->runtime_name = g_strdup(SELF(mailbox)->folder_name);
  }

  override (G:Object) void
    dispose (GObject *object)
  {
    Self *self = SELF(object);

    if (selfp->listener)
      {
	GNOME_MailNotification_Evolution_Glue glue;

	g_assert(selfp->glue != NULL);

	glue = mn_bonobo_unknown_get_object(selfp->glue);
	g_assert(glue != CORBA_OBJECT_NIL);

	g_static_mutex_lock(&listeners_mutex);
	mn_bonobo_event_source_client_remove_listener_locked(glue, selfp->listener, NULL);
	g_static_mutex_unlock(&listeners_mutex);

	bonobo_object_release_unref(glue, NULL);
	selfp->listener = NULL;
      }

    if (selfp->glue)
      {
	g_signal_handlers_disconnect_by_func(selfp->glue, mn_reentrant_mailbox_queue_check, self);
	mn_evolution_glue_client_unuse();
	selfp->glue = NULL;
      }

    PARENT_HANDLER(object);
  }

  private void
    listener_cb (BonoboListener *listener,
		 const char *event_name,
		 const CORBA_any *any,
		 CORBA_Environment *env,
		 gpointer user_data)
  {
    Self *self = user_data;
    const char *uri;

    if (! strcmp(event_name, MN_EVOLUTION_GLUE_EVENT_PREFIX ":" MN_EVOLUTION_GLUE_EVENT_MESSAGE_READING))
      {
	uri = BONOBO_ARG_GET_STRING(any);
	if (! strcmp(uri, self->uri))
	  {
	    time_t now = mn_time();

	    mn_reentrant_mailbox_lock(MN_REENTRANT_MAILBOX(self));
	    selfp->last_browsed = now;
	    mn_reentrant_mailbox_unlock(MN_REENTRANT_MAILBOX(self));

	    mn_reentrant_mailbox_queue_check(MN_REENTRANT_MAILBOX(self));
	  }
      }
    else if (! strcmp(event_name, MN_EVOLUTION_GLUE_EVENT_PREFIX ":" MN_EVOLUTION_GLUE_EVENT_FOLDER_CHANGED))
      {
	uri = BONOBO_ARG_GET_STRING(any);
	if (! strcmp(uri, self->uri))
	  mn_reentrant_mailbox_queue_check(MN_REENTRANT_MAILBOX(self));
      }
  }

  override (MN:Reentrant:Mailbox) void
    reentrant_check (MNReentrantMailbox *mailbox, unsigned long check_id)
  {
    Self *self = SELF(mailbox);
    GNOME_MailNotification_Evolution_Glue glue;
    CORBA_Environment env;
    CORBA_sequence_GNOME_MailNotification_Evolution_Message *message_seq;
    time_t last_browsed;

    mn_reentrant_mailbox_lock(mailbox);

    if (! selfp->glue)
      {
	selfp->glue = mn_evolution_glue_client_use();
	g_signal_connect_swapped(selfp->glue, "notify::object", G_CALLBACK(mn_reentrant_mailbox_queue_check), self);
      }

    glue = mn_bonobo_unknown_get_object(selfp->glue);

    if (glue == CORBA_OBJECT_NIL)
      {
	if (selfp->listener)
	  {
	    mn_bonobo_event_source_client_remove_listener_locked(CORBA_OBJECT_NIL, selfp->listener, NULL);
	    selfp->listener = NULL;
	  }
      }
    else
      {
	if (! selfp->listener)
	  selfp->listener = mn_bonobo_event_source_client_add_listener_full_locked(glue,
										   self_listener_cb,
										   MN_EVOLUTION_GLUE_EVENT_PREFIX,
										   NULL,
										   self,
										   (MNLockFunc) mn_g_static_mutex_lock,
										   (MNUnlockFunc) mn_g_static_mutex_unlock,
										   &listeners_mutex);
      }

    if (! selfp->listener && glue != CORBA_OBJECT_NIL)
      {
	bonobo_object_release_unref(glue, NULL);
	glue = CORBA_OBJECT_NIL;
      }

    last_browsed = selfp->last_browsed;

    mn_reentrant_mailbox_unlock(mailbox);

    if (glue == CORBA_OBJECT_NIL)
      {
	GDK_THREADS_ENTER();

	if (! mn_reentrant_mailbox_check_aborted_unlocked(mailbox, check_id))
	  {
	    mn_mailbox_set_error(MN_MAILBOX(self), _("unable to contact Evolution"));

	    if (mn_mailbox_get_poll(MN_MAILBOX(self)))
	      mn_mailbox_set_poll(MN_MAILBOX(self), FALSE);
	  }

	gdk_flush();
	GDK_THREADS_LEAVE();

	return;
      }

    CORBA_exception_init(&env);

    message_seq = GNOME_MailNotification_Evolution_Glue_getUnseenMessages(glue, self->uri, &env);

    if (BONOBO_EX(&env))
      {
	GDK_THREADS_ENTER();

	if (! mn_reentrant_mailbox_check_aborted_unlocked(mailbox, check_id))
	  {
	    char *errmsg;

	    errmsg = bonobo_exception_get_text(&env);
	    mn_mailbox_set_error(MN_MAILBOX(self), "%s", errmsg);
	    g_free(errmsg);

	    if (! mn_mailbox_get_poll(MN_MAILBOX(self)))
	      /*
	       * If the folder was not found, we will no longer
	       * receive events from Evolution, and we must therefore
	       * re-enable polling.
	       */
	      mn_mailbox_set_poll(MN_MAILBOX(self), TRUE);
	  }

	gdk_flush();
	GDK_THREADS_LEAVE();
      }
    else
      {
	int i;
	GSList *messages = NULL;

	for (i = 0; i < message_seq->_length; i++)
	  {
	    MNMessageFlags flags = 0;

	    if (message_seq->_buffer[i].received_time > last_browsed)
	      flags |= MN_MESSAGE_NEW;

#define unbox(str) (*(str) ? (str) : NULL)
	    messages = g_slist_prepend(messages, mn_evolution_message_new(MN_MAILBOX(mailbox),
									  message_seq->_buffer[i].sent_time,
									  message_seq->_buffer[i].id,
									  unbox(message_seq->_buffer[i].from),
									  unbox(message_seq->_buffer[i].subject),
									  flags,
									  message_seq->_buffer[i].uid));

	    if (mn_reentrant_mailbox_check_aborted(mailbox, check_id))
	      break;
	  }

	GDK_THREADS_ENTER();

	if (! mn_reentrant_mailbox_check_aborted_unlocked(mailbox, check_id))
	  {
	    mn_mailbox_set_messages(MN_MAILBOX(self), messages);

	    if (mn_mailbox_get_poll(MN_MAILBOX(self)))
	      mn_mailbox_set_poll(MN_MAILBOX(self), FALSE);
	  }

	mn_g_object_slist_free(messages);

	gdk_flush();
	GDK_THREADS_LEAVE();

	CORBA_free(message_seq);
      }

    CORBA_exception_free(&env);
    bonobo_object_release_unref(glue, NULL);
  }
}
