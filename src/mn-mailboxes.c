/* Generated by GOB (v2.0.14)   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 14

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "mn-mailboxes.h"

#include "mn-mailboxes-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 29 "mn-mailboxes.gob"

#include "config.h"
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <errno.h>
#include <glib/gi18n.h>
#include <libxml/parser.h>
#include <libxml/tree.h>
#include <eel/eel.h>
#include "mn-conf.h"
#include "mn-message.h"
#include "mn-mailbox-private.h"

#line 43 "mn-mailboxes.c"
/* self casting macros */
#define SELF(x) MN_MAILBOXES(x)
#define SELF_CONST(x) MN_MAILBOXES_CONST(x)
#define IS_SELF(x) MN_IS_MAILBOXES(x)
#define TYPE_SELF MN_TYPE_MAILBOXES
#define SELF_CLASS(x) MN_MAILBOXES_CLASS(x)

#define SELF_GET_CLASS(x) MN_MAILBOXES_GET_CLASS(x)

/* self typedefs */
typedef MNMailboxes Self;
typedef MNMailboxesClass SelfClass;

/* here are local prototypes */
static void ___object_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec);
static void mn_mailboxes_class_init (MNMailboxesClass * c) G_GNUC_UNUSED;
static void ___real_mn_mailboxes_mailbox_added (MNMailboxes * self, MNMailbox * mailbox);
static void mn_mailboxes_mailbox_added (MNMailboxes * self, MNMailbox * mailbox) G_GNUC_UNUSED;
static void ___real_mn_mailboxes_mailbox_removed (MNMailboxes * self, MNMailbox * mailbox);
static void mn_mailboxes_mailbox_removed (MNMailboxes * self, MNMailbox * mailbox) G_GNUC_UNUSED;
static void mn_mailboxes_mailbox_notify (MNMailboxes * self, MNMailbox * mailbox, GParamSpec * pspec) G_GNUC_UNUSED;
static void ___real_mn_mailboxes_list_changed (MNMailboxes * self);
static void mn_mailboxes_list_changed (MNMailboxes * self) G_GNUC_UNUSED;
static void ___real_mn_mailboxes_messages_changed (MNMailboxes * self, gboolean has_new);
static void mn_mailboxes_messages_changed (MNMailboxes * self, gboolean has_new) G_GNUC_UNUSED;
static int mn_mailboxes_messages_sort_cb (MNMessage * a, MNMessage * b) G_GNUC_UNUSED;
static void mn_mailboxes_error_changed (MNMailboxes * self) G_GNUC_UNUSED;
static void mn_mailboxes_init (MNMailboxes * self) G_GNUC_UNUSED;
static void ___a_mn_mailboxes_finalize (GObject * object) G_GNUC_UNUSED;
static void mn_mailboxes_add_error (GString ** errors, int * n_errors, const char * format, ...) G_GNUC_UNUSED;
static gboolean mn_mailboxes_load_real (MNMailboxes * self, GError ** err) G_GNUC_UNUSED;
static gboolean mn_mailboxes_save_real (MNMailboxes * self, GError ** err) G_GNUC_UNUSED;
static void mn_mailboxes_mailbox_messages_changed_h (MNMailbox * mailbox, gboolean has_new, gpointer user_data) G_GNUC_UNUSED;
static void mn_mailboxes_mailbox_notify_h (GObject * object, GParamSpec * pspec, gpointer user_data) G_GNUC_UNUSED;
static void mn_mailboxes_mailbox_notify_error_h (GObject * object, GParamSpec * pspec, gpointer user_data) G_GNUC_UNUSED;
static void mn_mailboxes_mailbox_notify_poll_h (GObject * object, GParamSpec * pspec, gpointer user_data) G_GNUC_UNUSED;
static void mn_mailboxes_add_real (MNMailboxes * self, MNMailbox * mailbox) G_GNUC_UNUSED;
static void mn_mailboxes_remove_real (MNMailboxes * self, MNMailbox * mailbox) G_GNUC_UNUSED;
static gboolean mn_mailboxes_queue_idle_cb (gpointer data) G_GNUC_UNUSED;

/*
 * Signal connection wrapper macro shortcuts
 */
#define self_connect__mailbox_added(object,func,data)	mn_mailboxes_connect__mailbox_added((object),(func),(data))
#define self_connect_after__mailbox_added(object,func,data)	mn_mailboxes_connect_after__mailbox_added((object),(func),(data))
#define self_connect_data__mailbox_added(object,func,data,destroy_data,flags)	mn_mailboxes_connect_data__mailbox_added((object),(func),(data),(destroy_data),(flags))
#define self_connect__mailbox_removed(object,func,data)	mn_mailboxes_connect__mailbox_removed((object),(func),(data))
#define self_connect_after__mailbox_removed(object,func,data)	mn_mailboxes_connect_after__mailbox_removed((object),(func),(data))
#define self_connect_data__mailbox_removed(object,func,data,destroy_data,flags)	mn_mailboxes_connect_data__mailbox_removed((object),(func),(data),(destroy_data),(flags))
#define self_connect__mailbox_notify(object,func,data)	mn_mailboxes_connect__mailbox_notify((object),(func),(data))
#define self_connect_after__mailbox_notify(object,func,data)	mn_mailboxes_connect_after__mailbox_notify((object),(func),(data))
#define self_connect_data__mailbox_notify(object,func,data,destroy_data,flags)	mn_mailboxes_connect_data__mailbox_notify((object),(func),(data),(destroy_data),(flags))
#define self_connect__list_changed(object,func,data)	mn_mailboxes_connect__list_changed((object),(func),(data))
#define self_connect_after__list_changed(object,func,data)	mn_mailboxes_connect_after__list_changed((object),(func),(data))
#define self_connect_data__list_changed(object,func,data,destroy_data,flags)	mn_mailboxes_connect_data__list_changed((object),(func),(data),(destroy_data),(flags))
#define self_connect__messages_changed(object,func,data)	mn_mailboxes_connect__messages_changed((object),(func),(data))
#define self_connect_after__messages_changed(object,func,data)	mn_mailboxes_connect_after__messages_changed((object),(func),(data))
#define self_connect_data__messages_changed(object,func,data,destroy_data,flags)	mn_mailboxes_connect_data__messages_changed((object),(func),(data),(destroy_data),(flags))
#define self_connect__error_changed(object,func,data)	mn_mailboxes_connect__error_changed((object),(func),(data))
#define self_connect_after__error_changed(object,func,data)	mn_mailboxes_connect_after__error_changed((object),(func),(data))
#define self_connect_data__error_changed(object,func,data,destroy_data,flags)	mn_mailboxes_connect_data__error_changed((object),(func),(data),(destroy_data),(flags))

typedef void  (*___Sig1) (MNMailboxes *, GObject *, gpointer);

static void
___marshal_Sig1 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig1 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 2);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig1) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((MNMailboxes *)data1,
		(GObject *) g_value_get_object (param_values + 1),
		data2);
}


typedef void  (*___Sig2) (MNMailboxes *, GObject *, gpointer , gpointer);

static void
___marshal_Sig2 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig2 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 3);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig2) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((MNMailboxes *)data1,
		(GObject *) g_value_get_object (param_values + 1),
		(gpointer ) g_value_get_pointer (param_values + 2),
		data2);
}


typedef void  (*___Sig3) (MNMailboxes *, gboolean , gpointer);

static void
___marshal_Sig3 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig3 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 2);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig3) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((MNMailboxes *)data1,
		(gboolean ) g_value_get_boolean (param_values + 1),
		data2);
}


enum {
	MAILBOX_ADDED_SIGNAL,
	MAILBOX_REMOVED_SIGNAL,
	MAILBOX_NOTIFY_SIGNAL,
	LIST_CHANGED_SIGNAL,
	MESSAGES_CHANGED_SIGNAL,
	ERROR_CHANGED_SIGNAL,
	LAST_SIGNAL
};

enum {
	PROP_0,
	PROP_POLL
};

static guint object_signals[LAST_SIGNAL] = {0};

/* pointer to the class of our parent */
static GObjectClass *parent_class = NULL;

/* Short form macros */
#define self_mailbox_added mn_mailboxes_mailbox_added
#define self_mailbox_removed mn_mailboxes_mailbox_removed
#define self_mailbox_notify mn_mailboxes_mailbox_notify
#define self_list_changed mn_mailboxes_list_changed
#define self_messages_changed mn_mailboxes_messages_changed
#define self_messages_sort_cb mn_mailboxes_messages_sort_cb
#define self_error_changed mn_mailboxes_error_changed
#define self_get_poll mn_mailboxes_get_poll
#define self_load mn_mailboxes_load
#define self_add_error mn_mailboxes_add_error
#define self_load_real mn_mailboxes_load_real
#define self_save mn_mailboxes_save
#define self_save_real mn_mailboxes_save_real
#define self_mailbox_messages_changed_h mn_mailboxes_mailbox_messages_changed_h
#define self_mailbox_notify_h mn_mailboxes_mailbox_notify_h
#define self_mailbox_notify_error_h mn_mailboxes_mailbox_notify_error_h
#define self_mailbox_notify_poll_h mn_mailboxes_mailbox_notify_poll_h
#define self_check mn_mailboxes_check
#define self_add_real mn_mailboxes_add_real
#define self_add mn_mailboxes_add
#define self_queue_add mn_mailboxes_queue_add
#define self_remove_real mn_mailboxes_remove_real
#define self_queue_remove mn_mailboxes_queue_remove
#define self_queue_idle_cb mn_mailboxes_queue_idle_cb
#define self_compare_by_name_func mn_mailboxes_compare_by_name_func
#define self_new mn_mailboxes_new
GType
mn_mailboxes_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (MNMailboxesClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) mn_mailboxes_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (MNMailboxes),
			0 /* n_preallocs */,
			(GInstanceInitFunc) mn_mailboxes_init,
			NULL
		};

		type = g_type_register_static (G_TYPE_OBJECT, "MNMailboxes", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((MNMailboxes *)g_object_new(mn_mailboxes_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static MNMailboxes * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static MNMailboxes *
GET_NEW_VARG (const char *first, ...)
{
	MNMailboxes *ret;
	va_list ap;
	va_start (ap, first);
	ret = (MNMailboxes *)g_object_new_valist (mn_mailboxes_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "MN:Mailboxes::finalize"
	MNMailboxes *self G_GNUC_UNUSED = MN_MAILBOXES (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
#line 247 "mn-mailboxes.gob"
	___a_mn_mailboxes_finalize(obj_self);
#line 301 "mn-mailboxes.c"
#line 48 "mn-mailboxes.gob"
	if(self->list) { eel_g_object_list_free ((gpointer) self->list); self->list = NULL; }
#line 304 "mn-mailboxes.c"
#line 49 "mn-mailboxes.gob"
	if(self->messages) { mn_g_object_slist_free ((gpointer) self->messages); self->messages = NULL; }
#line 307 "mn-mailboxes.c"
#line 51 "mn-mailboxes.gob"
	if(self->_priv->add_queue) { mn_g_object_slist_free ((gpointer) self->_priv->add_queue); self->_priv->add_queue = NULL; }
#line 310 "mn-mailboxes.c"
#line 52 "mn-mailboxes.gob"
	if(self->_priv->remove_queue) { mn_g_object_slist_free ((gpointer) self->_priv->remove_queue); self->_priv->remove_queue = NULL; }
#line 313 "mn-mailboxes.c"
}
#undef __GOB_FUNCTION__

static void 
mn_mailboxes_class_init (MNMailboxesClass * c G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "MN:Mailboxes::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) c;

	g_type_class_add_private(c,sizeof(MNMailboxesPrivate));

	parent_class = g_type_class_ref (G_TYPE_OBJECT);

	object_signals[MAILBOX_ADDED_SIGNAL] =
		g_signal_new ("mailbox_added",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST),
			G_STRUCT_OFFSET (MNMailboxesClass, mailbox_added),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 1,
			G_TYPE_OBJECT);
	if ___GOB_UNLIKELY(sizeof(MNMailbox * ) != sizeof(GObject *) || parent_class == NULL /* avoid warning */) {
		g_error("mn-mailboxes.gob line 62: Type mismatch of \"mailbox_added\" signal signature");
	}
	object_signals[MAILBOX_REMOVED_SIGNAL] =
		g_signal_new ("mailbox_removed",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST),
			G_STRUCT_OFFSET (MNMailboxesClass, mailbox_removed),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 1,
			G_TYPE_OBJECT);
	if ___GOB_UNLIKELY(sizeof(MNMailbox * ) != sizeof(GObject *) || parent_class == NULL /* avoid warning */) {
		g_error("mn-mailboxes.gob line 85: Type mismatch of \"mailbox_removed\" signal signature");
	}
	object_signals[MAILBOX_NOTIFY_SIGNAL] =
		g_signal_new ("mailbox_notify",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED),
			G_STRUCT_OFFSET (MNMailboxesClass, mailbox_notify),
			NULL, NULL,
			___marshal_Sig2,
			G_TYPE_NONE, 2,
			G_TYPE_OBJECT,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(MNMailbox * ) != sizeof(GObject *) || sizeof(GParamSpec * ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("mn-mailboxes.gob line 104: Type mismatch of \"mailbox_notify\" signal signature");
	}
	object_signals[LIST_CHANGED_SIGNAL] =
		g_signal_new ("list_changed",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST),
			G_STRUCT_OFFSET (MNMailboxesClass, list_changed),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);
	object_signals[MESSAGES_CHANGED_SIGNAL] =
		g_signal_new ("messages_changed",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_FIRST),
			G_STRUCT_OFFSET (MNMailboxesClass, messages_changed),
			NULL, NULL,
			___marshal_Sig3,
			G_TYPE_NONE, 1,
			G_TYPE_BOOLEAN);
	if ___GOB_UNLIKELY(sizeof(gboolean ) != sizeof(gboolean ) || parent_class == NULL /* avoid warning */) {
		g_error("mn-mailboxes.gob line 138: Type mismatch of \"messages_changed\" signal signature");
	}
	object_signals[ERROR_CHANGED_SIGNAL] =
		g_signal_new ("error_changed",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST),
			G_STRUCT_OFFSET (MNMailboxesClass, error_changed),
			NULL, NULL,
			g_cclosure_marshal_VOID__VOID,
			G_TYPE_NONE, 0);

#line 62 "mn-mailboxes.gob"
	c->mailbox_added = ___real_mn_mailboxes_mailbox_added;
#line 85 "mn-mailboxes.gob"
	c->mailbox_removed = ___real_mn_mailboxes_mailbox_removed;
#line 397 "mn-mailboxes.c"
	c->mailbox_notify = NULL;
#line 117 "mn-mailboxes.gob"
	c->list_changed = ___real_mn_mailboxes_list_changed;
#line 138 "mn-mailboxes.gob"
	c->messages_changed = ___real_mn_mailboxes_messages_changed;
#line 403 "mn-mailboxes.c"
	c->error_changed = NULL;
#line 247 "mn-mailboxes.gob"
	g_object_class->finalize = ___finalize;
#line 407 "mn-mailboxes.c"
	g_object_class->get_property = ___object_get_property;
    {
	GParamSpec   *param_spec;

	param_spec = g_param_spec_boolean
		("poll" /* name */,
		 NULL /* nick */,
		 NULL /* blurb */,
		 FALSE /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE));
	g_object_class_install_property (g_object_class,
		PROP_POLL,
		param_spec);
    }
}
#undef __GOB_FUNCTION__
#line 194 "mn-mailboxes.gob"
static void 
mn_mailboxes_init (MNMailboxes * self G_GNUC_UNUSED)
#line 427 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::init"
	self->_priv = G_TYPE_INSTANCE_GET_PRIVATE(self,MN_TYPE_MAILBOXES,MNMailboxesPrivate);
 {
#line 195 "mn-mailboxes.gob"

    char *filename;
    gboolean exists;

    filename = g_build_filename(mn_conf_dot_dir, "mailboxes.xml", NULL);
    exists = g_file_test(filename, G_FILE_TEST_EXISTS);
    g_free(filename);

    if (exists)
      self_load(self);
    else if (mn_conf_is_set(MN_CONF_OBSOLETE_MAILBOXES))
      {
	GSList *gconf_mailboxes;
	GSList *l;
	GSList *invalid_uri_list = NULL;
	gboolean list_changed = FALSE;

	gconf_mailboxes = eel_gconf_get_string_list(MN_CONF_OBSOLETE_MAILBOXES);
	MN_LIST_FOREACH(l, gconf_mailboxes)
	  {
	    const char *uri = l->data;
	    MNMailbox *mailbox;

	    mailbox = mn_mailbox_new_from_obsolete_uri(uri);
	    if (mailbox)
	      {
		mn_mailbox_seal(mailbox);
		self_add_real(self, mailbox);
		g_object_unref(mailbox);

		list_changed = TRUE;
	      }
	    else
	      invalid_uri_list = g_slist_append(invalid_uri_list, (gpointer) uri);
	  }

	if (list_changed)
	  {
	    self_list_changed(self);
	    self_save(self);	/* save the imported mailboxes */
	  }

	if (invalid_uri_list)
	  {
	    mn_invalid_uri_list_dialog(NULL, _("An error has occurred while importing old mailboxes"), invalid_uri_list);
	    g_slist_free(invalid_uri_list);
	  }

	eel_g_slist_free_deep(gconf_mailboxes);
      }
  
#line 484 "mn-mailboxes.c"
 }
}
#undef __GOB_FUNCTION__

static void
___object_get_property (GObject *object,
	guint property_id,
	GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "MN:Mailboxes::get_property"
{
	MNMailboxes *self G_GNUC_UNUSED;

	self = MN_MAILBOXES (object);

	switch (property_id) {
	case PROP_POLL:
		{
#line 176 "mn-mailboxes.gob"

      gboolean global_poll = FALSE;
      GList *l;

      MN_LIST_FOREACH(l, self->list)
	{
	  MNMailbox *mailbox = l->data;

	  if (mn_mailbox_get_poll(mailbox))
	    {
	      global_poll = TRUE;
	      break;
	    }
	}

      g_value_set_boolean(VAL, global_poll);
    
#line 521 "mn-mailboxes.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__


#line 62 "mn-mailboxes.gob"
static void 
mn_mailboxes_mailbox_added (MNMailboxes * self, MNMailbox * mailbox)
#line 540 "mn-mailboxes.c"
{
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 62 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 62 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 62 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 62 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 556 "mn-mailboxes.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_OBJECT);
	g_value_set_object (&___param_values[1], (GObject *) mailbox);

	g_signal_emitv (___param_values,
		object_signals[MAILBOX_ADDED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
#line 62 "mn-mailboxes.gob"
static void 
___real_mn_mailboxes_mailbox_added (MNMailboxes * self G_GNUC_UNUSED, MNMailbox * mailbox)
#line 577 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::mailbox_added"
{
#line 64 "mn-mailboxes.gob"
	
    /* connect signals */
    g_object_connect(mailbox,
		     "signal::messages-changed", self_mailbox_messages_changed_h, self,
		     "signal::notify", self_mailbox_notify_h, self,
		     "signal::notify::error", self_mailbox_notify_error_h, self,
		     "signal::notify::poll", self_mailbox_notify_poll_h, self,
		     NULL);

    /* emit the "added" signal on the mailbox */
    mn_mailbox_added(mailbox);
  }}
#line 594 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 85 "mn-mailboxes.gob"
static void 
mn_mailboxes_mailbox_removed (MNMailboxes * self, MNMailbox * mailbox)
#line 600 "mn-mailboxes.c"
{
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 85 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 85 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 85 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 85 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 616 "mn-mailboxes.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_OBJECT);
	g_value_set_object (&___param_values[1], (GObject *) mailbox);

	g_signal_emitv (___param_values,
		object_signals[MAILBOX_REMOVED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
#line 85 "mn-mailboxes.gob"
static void 
___real_mn_mailboxes_mailbox_removed (MNMailboxes * self G_GNUC_UNUSED, MNMailbox * mailbox)
#line 637 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::mailbox_removed"
{
#line 87 "mn-mailboxes.gob"
	
    /* disconnect signals */
    g_object_disconnect(mailbox,
			"any-signal", self_mailbox_messages_changed_h, self,
			"any-signal", self_mailbox_notify_h, self,
			"any-signal", self_mailbox_notify_error_h, self,
			"any-signal", self_mailbox_notify_poll_h, self,
			NULL);

    /* emit the "removed" signal on the mailbox */
    mn_mailbox_removed(mailbox);

    /* messages and error have possibly changed */
    self_messages_changed(self, FALSE);
    self_error_changed(self);
  }}
#line 658 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 104 "mn-mailboxes.gob"
static void 
mn_mailboxes_mailbox_notify (MNMailboxes * self, MNMailbox * mailbox, GParamSpec * pspec)
#line 664 "mn-mailboxes.c"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 104 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 104 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 104 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 104 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 104 "mn-mailboxes.gob"
	g_return_if_fail (pspec != NULL);
#line 682 "mn-mailboxes.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_OBJECT);
	g_value_set_object (&___param_values[1], (GObject *) mailbox);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[2], (gpointer ) pspec);

	g_signal_emitv (___param_values,
		object_signals[MAILBOX_NOTIFY_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}

#line 117 "mn-mailboxes.gob"
static void 
mn_mailboxes_list_changed (MNMailboxes * self)
#line 709 "mn-mailboxes.c"
{
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 117 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 117 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 721 "mn-mailboxes.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[LIST_CHANGED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}
#line 117 "mn-mailboxes.gob"
static void 
___real_mn_mailboxes_list_changed (MNMailboxes * self G_GNUC_UNUSED)
#line 737 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::list_changed"
{
#line 119 "mn-mailboxes.gob"
	
    /* poll has possibly changed */
    g_object_notify(G_OBJECT(self), "poll");
  }}
#line 746 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 138 "mn-mailboxes.gob"
static void 
mn_mailboxes_messages_changed (MNMailboxes * self, gboolean has_new)
#line 752 "mn-mailboxes.c"
{
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 138 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 138 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 764 "mn-mailboxes.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_BOOLEAN);
	g_value_set_boolean (&___param_values[1], (gboolean ) has_new);

	g_signal_emitv (___param_values,
		object_signals[MESSAGES_CHANGED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
#line 138 "mn-mailboxes.gob"
static void 
___real_mn_mailboxes_messages_changed (MNMailboxes * self G_GNUC_UNUSED, gboolean has_new)
#line 785 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::messages_changed"
{
#line 140 "mn-mailboxes.gob"
	
    GList *la;

    mn_g_object_slist_clear(&self->messages);

    MN_LIST_FOREACH(la, self->list)
      {
	MNMailbox *mailbox = la->data;
	GSList *lb;

	MN_LIST_FOREACH(lb, mailbox->messages)
	  self->messages = g_slist_insert_sorted(self->messages, g_object_ref(lb->data), (GCompareFunc) self_messages_sort_cb);
      }
  }}
#line 804 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 155 "mn-mailboxes.gob"
static int 
mn_mailboxes_messages_sort_cb (MNMessage * a, MNMessage * b)
#line 810 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::messages_sort_cb"
{
#line 157 "mn-mailboxes.gob"
	
    /* sort by sent time in descending order */
    return b->sent_time - a->sent_time;
  }}
#line 819 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 171 "mn-mailboxes.gob"
static void 
mn_mailboxes_error_changed (MNMailboxes * self)
#line 825 "mn-mailboxes.c"
{
	GValue ___param_values[1];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 171 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 171 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 837 "mn-mailboxes.c"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	g_signal_emitv (___param_values,
		object_signals[ERROR_CHANGED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
}

#line 176 "mn-mailboxes.gob"
gboolean 
mn_mailboxes_get_poll (MNMailboxes * self)
#line 854 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::get_poll"
{
#line 174 "mn-mailboxes.gob"
		gboolean val; g_object_get (G_OBJECT (self), "poll", &val, NULL); return val;
}}
#line 861 "mn-mailboxes.c"
#undef __GOB_FUNCTION__


#line 247 "mn-mailboxes.gob"
static void 
___a_mn_mailboxes_finalize (GObject * object G_GNUC_UNUSED)
#line 868 "mn-mailboxes.c"
#define PARENT_HANDLER(___object) \
	{ if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(___object); }
{
#define __GOB_FUNCTION__ "MN:Mailboxes::finalize"
{
#line 249 "mn-mailboxes.gob"
	
    Self *self = SELF(object);

    if (selfp->queue_idle_source)
      mn_locked_g_source_remove(selfp->queue_idle_source);

    PARENT_HANDLER(object);
  }}
#line 884 "mn-mailboxes.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 258 "mn-mailboxes.gob"
void 
mn_mailboxes_load (MNMailboxes * self)
#line 891 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::load"
#line 258 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 258 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 898 "mn-mailboxes.c"
{
#line 260 "mn-mailboxes.gob"
	
    GError *err = NULL;

    if (! self_load_real(self, &err))
      {
	mn_error_dialog(NULL, _("Unable to load the mailboxes configuration"), "%s", err->message);
	g_error_free(err);
      }
  }}
#line 910 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 270 "mn-mailboxes.gob"
static void 
mn_mailboxes_add_error (GString ** errors, int * n_errors, const char * format, ...)
#line 916 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::add_error"
#line 270 "mn-mailboxes.gob"
	g_return_if_fail (errors != NULL);
#line 270 "mn-mailboxes.gob"
	g_return_if_fail (n_errors != NULL);
#line 923 "mn-mailboxes.c"
{
#line 274 "mn-mailboxes.gob"
	
    va_list args;
    char *message;

    if (*errors)
      g_string_append_c(*errors, '\n');
    else
      *errors = g_string_new(NULL);

    va_start(args, format);
    message = g_strdup_vprintf(format, args);
    va_end(args);

    g_string_append(*errors, message);
    g_free(message);

    (*n_errors)++;
  }}
#line 944 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 293 "mn-mailboxes.gob"
static gboolean 
mn_mailboxes_load_real (MNMailboxes * self, GError ** err)
#line 950 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::load_real"
#line 293 "mn-mailboxes.gob"
	g_return_val_if_fail (self != NULL, (gboolean )0);
#line 293 "mn-mailboxes.gob"
	g_return_val_if_fail (MN_IS_MAILBOXES (self), (gboolean )0);
#line 957 "mn-mailboxes.c"
{
#line 295 "mn-mailboxes.gob"
	
    char *filename;
    xmlDoc *doc;
    xmlNode *root;
    xmlNode *node;
    gboolean list_changed = FALSE;
    gboolean status = TRUE;
    GString *errors = NULL;
    int n_errors = 0;

    filename = g_build_filename(mn_conf_dot_dir, "mailboxes.xml", NULL);
    doc = xmlParseFile(filename);
    g_free(filename);

    if (! doc)
      {
	g_set_error(err, 0, 0, _("Unable to parse the XML document."));
	return FALSE;
      }

    root = xmlDocGetRootElement(doc);
    if (! root)
      {
	g_set_error(err, 0, 0, _("The root element is missing."));
	goto error;
      }

    if (strcmp(root->name, "mailboxes"))
      {
	g_set_error(err, 0, 0, _("The root element \"%s\" is invalid."), root->name);
	goto error;
      }

    for (node = root->children; node; node = node->next)
      if (node->type == XML_ELEMENT_NODE)
	{
	  if (! strcmp(node->name, "mailbox"))
	    {
	      MNMailbox *mailbox;
	      GError *tmp_err = NULL;

	      mailbox = mn_mailbox_new_from_xml_node(node, &tmp_err);
	      if (mailbox)
		{
		  mn_mailbox_seal(mailbox);
		  self_add_real(self, mailbox);
		  g_object_unref(mailbox);

		  list_changed = TRUE;
		}
	      else
		{
		  self_add_error(&errors, &n_errors, _("On line %i: %s."), node->line, tmp_err->message);
		  g_error_free(tmp_err);
		}
	    }
	  else
	    self_add_error(&errors, &n_errors, _("On line %i: unknown element \"%s\"."), node->line, node->name);
	}

    if (list_changed)
      self_list_changed(self);

    if (errors)
      {
	mn_error_dialog(NULL,
			ngettext("An error has occurred while loading the mailboxes configuration",
				 "Errors have occurred while loading the mailboxes configuration",
				 n_errors),
			"%s", errors->str);
	g_string_free(errors, TRUE);
      }

    goto end;

  error:
    status = FALSE;

  end:
    xmlFreeDoc(doc);

    return status;
  }}
#line 1043 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 379 "mn-mailboxes.gob"
void 
mn_mailboxes_save (MNMailboxes * self)
#line 1049 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::save"
#line 379 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 379 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 1056 "mn-mailboxes.c"
{
#line 381 "mn-mailboxes.gob"
	
    GError *err = NULL;

    if (! self_save_real(self, &err))
      {
	mn_error_dialog(NULL, _("Unable to save the mailboxes configuration"), "%s", err->message);
	g_error_free(err);
      }
  }}
#line 1068 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 391 "mn-mailboxes.gob"
static gboolean 
mn_mailboxes_save_real (MNMailboxes * self, GError ** err)
#line 1074 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::save_real"
#line 391 "mn-mailboxes.gob"
	g_return_val_if_fail (self != NULL, (gboolean )0);
#line 391 "mn-mailboxes.gob"
	g_return_val_if_fail (MN_IS_MAILBOXES (self), (gboolean )0);
#line 1081 "mn-mailboxes.c"
{
#line 393 "mn-mailboxes.gob"
	
    int indent;
    xmlDoc *doc;
    xmlNode *root;
    GList *l;
    char *filename;
    char *tmp_filename;
    char *old_filename;
    int fd = -1;
    FILE *f = NULL;
    gboolean old_exists;
    gboolean status = TRUE;

    indent = xmlIndentTreeOutput;
    xmlIndentTreeOutput = 1;

    doc = xmlNewDoc("1.0");
    root = xmlNewNode(NULL, "mailboxes");
    xmlDocSetRootElement(doc, root);

    MN_LIST_FOREACH(l, self->list)
      {
	MNMailbox *mailbox = l->data;
	xmlNode *node;

	node = mn_mailbox_xml_node_new(mailbox);
	xmlAddChild(root, node); /* owns node */
      }

    filename = g_build_filename(mn_conf_dot_dir, "mailboxes.xml", NULL);
    tmp_filename = g_strconcat(filename, ".tmp", NULL);
    old_filename = g_strconcat(filename, ".old", NULL);

    if (g_file_test(tmp_filename, G_FILE_TEST_EXISTS) && unlink(tmp_filename) < 0)
      {
	g_set_error(err, 0, 0, _("Unable to remove %s: %s."), tmp_filename, g_strerror(errno));
	goto error;
      }

    /* the file may contain passwords; restrict permissions (600) */
    fd = open(tmp_filename, O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
    if (fd < 0)
      {
	g_set_error(err, 0, 0, _("Unable to create %s: %s."), tmp_filename, g_strerror(errno));
	goto error;
      }

    f = fdopen(fd, "w");
    if (! f)
      {
	g_set_error(err, 0, 0, _("Unable to open %s for writing: %s."), tmp_filename, g_strerror(errno));
	goto error;
      }
    fd = -1;			/* now owned by f */

    if (xmlDocFormatDump(f, doc, 1) < 0)
      {
	g_set_error(err, 0, 0, _("Unable to write the XML document."));
	goto error;
      }

    if (fclose(f) != 0)
      {
	g_set_error(err, 0, 0, _("Unable to close %s: %s."), tmp_filename, g_strerror(errno));
	goto error;
      }
    f = NULL;

    old_exists = g_file_test(filename, G_FILE_TEST_EXISTS);
    if (old_exists)
      {
	if (rename(filename, old_filename) < 0)
	  {
	    g_set_error(err, 0, 0, _("Unable to rename %s to %s: %s."), filename, old_filename, g_strerror(errno));
	    goto error;
	  }
      }

    if (rename(tmp_filename, filename) < 0)
      {
	g_set_error(err, 0, 0, _("Unable to rename %s to %s: %s."), tmp_filename, filename, g_strerror(errno));
	goto error;
      }

    if (old_exists)
      if (unlink(old_filename) < 0) /* non fatal */
	g_warning(_("unable to delete %s: %s"), old_filename, g_strerror(errno));

    goto end;			/* success */

  error:
    status = FALSE;

  end:
    xmlFreeDoc(doc);
    xmlIndentTreeOutput = indent;

    g_free(filename);
    g_free(tmp_filename);
    g_free(old_filename);

    if (fd >= 0)
      close(fd);
    if (f)
      fclose(f);

    return status;
  }}
#line 1192 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 502 "mn-mailboxes.gob"
static void 
mn_mailboxes_mailbox_messages_changed_h (MNMailbox * mailbox, gboolean has_new, gpointer user_data)
#line 1198 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::mailbox_messages_changed_h"
{
#line 506 "mn-mailboxes.gob"
	
    Self *self = user_data;

    mn_info(ngettext("%s has %i new message", "%s has %i new messages", mailbox->n_messages),
	    mailbox->runtime_name, mailbox->n_messages);

    self_messages_changed(self, has_new);
  }}
#line 1211 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 515 "mn-mailboxes.gob"
static void 
mn_mailboxes_mailbox_notify_h (GObject * object, GParamSpec * pspec, gpointer user_data)
#line 1217 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::mailbox_notify_h"
{
#line 517 "mn-mailboxes.gob"
	
    Self *self = user_data;
    char *detailed_signal;

    detailed_signal = g_strconcat("mailbox-notify::", g_param_spec_get_name(pspec), NULL);
    g_signal_emit_by_name(self, detailed_signal, object, pspec);
    g_free(detailed_signal);
  }}
#line 1230 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 526 "mn-mailboxes.gob"
static void 
mn_mailboxes_mailbox_notify_error_h (GObject * object, GParamSpec * pspec, gpointer user_data)
#line 1236 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::mailbox_notify_error_h"
{
#line 530 "mn-mailboxes.gob"
	
    Self *self = user_data;
    MNMailbox *mailbox = MN_MAILBOX(object);

    if (mailbox->error)
      mn_info(_("%s reported an error: %s"), mailbox->runtime_name, mailbox->error);

    self_error_changed(self);
  }}
#line 1250 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 540 "mn-mailboxes.gob"
static void 
mn_mailboxes_mailbox_notify_poll_h (GObject * object, GParamSpec * pspec, gpointer user_data)
#line 1256 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::mailbox_notify_poll_h"
{
#line 544 "mn-mailboxes.gob"
	
    Self *self = user_data;

    /* poll has possibly changed */
    g_object_notify(G_OBJECT(self), "poll");
  }}
#line 1267 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 551 "mn-mailboxes.gob"
void 
mn_mailboxes_check (MNMailboxes * self)
#line 1273 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::check"
#line 551 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 551 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 1280 "mn-mailboxes.c"
{
#line 553 "mn-mailboxes.gob"
	
    GList *l;

    MN_LIST_FOREACH(l, self->list)
      {
	MNMailbox *mailbox = l->data;

	if (mn_mailbox_get_poll(mailbox))
	  mn_mailbox_check(mailbox);
      }
  }}
#line 1294 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 565 "mn-mailboxes.gob"
static void 
mn_mailboxes_add_real (MNMailboxes * self, MNMailbox * mailbox)
#line 1300 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::add_real"
#line 565 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 565 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 565 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 565 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 1311 "mn-mailboxes.c"
{
#line 567 "mn-mailboxes.gob"
	
    g_object_ref(mailbox);
    self->list = g_list_insert_sorted(self->list, mailbox, self_compare_by_name_func);
    self_mailbox_added(self, mailbox);
  }}
#line 1319 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 573 "mn-mailboxes.gob"
void 
mn_mailboxes_add (MNMailboxes * self, MNMailbox * mailbox)
#line 1325 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::add"
#line 573 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 573 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 573 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 573 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 1336 "mn-mailboxes.c"
{
#line 575 "mn-mailboxes.gob"
	
    self_add_real(self, mailbox);
    self_list_changed(self);
    self_save(self);
  }}
#line 1344 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 581 "mn-mailboxes.gob"
void 
mn_mailboxes_queue_add (MNMailboxes * self, MNMailbox * mailbox)
#line 1350 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::queue_add"
#line 581 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 581 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 581 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 581 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 1361 "mn-mailboxes.c"
{
#line 583 "mn-mailboxes.gob"
	
    g_object_ref(mailbox);
    selfp->add_queue = g_slist_append(selfp->add_queue, mailbox);

    if (! selfp->queue_idle_source)
      selfp->queue_idle_source = mn_g_idle_add_gdk_locked(self_queue_idle_cb, self);
  }}
#line 1371 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 591 "mn-mailboxes.gob"
static void 
mn_mailboxes_remove_real (MNMailboxes * self, MNMailbox * mailbox)
#line 1377 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::remove_real"
#line 591 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 591 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 591 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 591 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 1388 "mn-mailboxes.c"
{
#line 593 "mn-mailboxes.gob"
	
    self->list = g_list_remove(self->list, mailbox);
    self_mailbox_removed(self, mailbox);
    g_object_unref(mailbox);
  }}
#line 1396 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 599 "mn-mailboxes.gob"
void 
mn_mailboxes_queue_remove (MNMailboxes * self, MNMailbox * mailbox)
#line 1402 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::queue_remove"
#line 599 "mn-mailboxes.gob"
	g_return_if_fail (self != NULL);
#line 599 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOXES (self));
#line 599 "mn-mailboxes.gob"
	g_return_if_fail (mailbox != NULL);
#line 599 "mn-mailboxes.gob"
	g_return_if_fail (MN_IS_MAILBOX (mailbox));
#line 1413 "mn-mailboxes.c"
{
#line 601 "mn-mailboxes.gob"
	
    g_object_ref(mailbox);
    selfp->remove_queue = g_slist_append(selfp->remove_queue, mailbox);

    if (! selfp->queue_idle_source)
      selfp->queue_idle_source = mn_g_idle_add_gdk_locked(self_queue_idle_cb, self);
  }}
#line 1423 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 609 "mn-mailboxes.gob"
static gboolean 
mn_mailboxes_queue_idle_cb (gpointer data)
#line 1429 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::queue_idle_cb"
{
#line 611 "mn-mailboxes.gob"
	
    Self *self = data;
    GSList *l;

    MN_LIST_FOREACH(l, selfp->add_queue)
      self_add_real(self, l->data);

    mn_g_object_slist_clear(&selfp->add_queue);

    MN_LIST_FOREACH(l, selfp->remove_queue)
      self_remove_real(self, l->data);

    mn_g_object_slist_clear(&selfp->remove_queue);

    self_list_changed(self);
    self_save(self);

    selfp->queue_idle_source = NULL;
    return FALSE;		/* remove */
  }}
#line 1454 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 632 "mn-mailboxes.gob"
int 
mn_mailboxes_compare_by_name_func (gconstpointer a, gconstpointer b)
#line 1460 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::compare_by_name_func"
{
#line 634 "mn-mailboxes.gob"
	
    MNMailbox *mailbox_a = (MNMailbox *) a;
    MNMailbox *mailbox_b = (MNMailbox *) b;

    return g_utf8_collate(mailbox_a->runtime_name, mailbox_b->runtime_name);
  }}
#line 1471 "mn-mailboxes.c"
#undef __GOB_FUNCTION__

#line 641 "mn-mailboxes.gob"
MNMailboxes * 
mn_mailboxes_new (void)
#line 1477 "mn-mailboxes.c"
{
#define __GOB_FUNCTION__ "MN:Mailboxes::new"
{
#line 643 "mn-mailboxes.gob"
	
    return GET_NEW;
  }}
#line 1485 "mn-mailboxes.c"
#undef __GOB_FUNCTION__
