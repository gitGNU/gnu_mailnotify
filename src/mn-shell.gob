/* 
 * Copyright (c) 2004 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

%headertop{
#include "mn-mailboxes.h"
%}
%privateheader{
#include "mn-mail-icon.h"
%}
%{
#include "config.h"
#include <gnome.h>
#include "mn-properties.h"
#include "mn-dialog.h"
#include "mn-util.h"
#include "mn-conf.h"
#include "mn-mailboxes.h"
#include "mn-unsupported-mailbox.h"
#include "mn-about-dialog.h"

  MNShell *mn_shell = NULL;
%}

class MN:Shell from G:Object
{
  public MNMailboxes *mailboxes = {mn_mailboxes_new()} unrefwith g_object_unref;
  private MNMailIcon *icon;
  private GtkWidget *about;

  init (self)
  {
    g_return_if_fail(mn_shell == NULL);
    g_object_add_weak_pointer(G_OBJECT(self), (gpointer *) &mn_shell);

    self_init_icon(self);
    eel_gconf_notification_add(MN_CONF_COMMANDS_DOUBLE_CLICKED_COMMAND, self_notify_double_clicked_command_cb, self);

    g_signal_connect(G_OBJECT(self->mailboxes), "list-changed", G_CALLBACK(self_mailboxes_list_changed_h), self);
    g_signal_connect(G_OBJECT(self->mailboxes), "status-changed", G_CALLBACK(self_mailboxes_status_changed_h), self);
  }

  override (G:Object) void
    finalize (GObject *object)
  {
    gtk_main_quit();
    PARENT_HANDLER(object);
  }
  
  private void
    mailboxes_list_changed_h (MN:Mailboxes *mailboxes (check null type),
			      gpointer user_data (check null))
  {
    Self *self = user_data;
    
    self_update_sensitivity(self);
    self_update_icon(self);
  }

  private void
    mailboxes_status_changed_h (MN:Mailboxes *mailboxes (check null type),
				gpointer user_data (check null))
  {
    Self *self = user_data;

    self_update_icon(self);
  }
  
  private void
    init_icon (self)
  {
    selfp->icon = MN_MAIL_ICON(mn_mail_icon_new());

    g_signal_connect(G_OBJECT(selfp->icon), "activate", G_CALLBACK(self_icon_activate_h), self);
    g_signal_connect(G_OBJECT(selfp->icon), "activate-run", G_CALLBACK(self_icon_activate_run_h), self);
    g_signal_connect(G_OBJECT(selfp->icon), "activate-update", G_CALLBACK(self_icon_activate_update_h), self);
    g_signal_connect(G_OBJECT(selfp->icon), "activate-properties", G_CALLBACK(self_icon_activate_properties_h), self);
    g_signal_connect(G_OBJECT(selfp->icon), "activate-help", G_CALLBACK(self_icon_activate_help_h), self);
    g_signal_connect(G_OBJECT(selfp->icon), "activate-about", G_CALLBACK(self_icon_activate_about_h), self);
    g_signal_connect(G_OBJECT(selfp->icon), "activate-remove", G_CALLBACK(self_icon_activate_remove_h), self);
    g_signal_connect(G_OBJECT(selfp->icon), "destroy", G_CALLBACK(self_icon_destroy_h), self);

    self_update_command(self);
    self_update_sensitivity(self);
    self_update_icon(self);
  }

  private void
    notify_double_clicked_command_cb (GConfClient *client,
				      guint cnxn_id,
				      GConfEntry *entry,
				      gpointer user_data (check null))
  {
    Self *self = user_data;

    self_update_command(self);
  }

  private void
    icon_activate_h (MN:Mail:Icon *icon (check null type),
		     gpointer user_data (check null))
  {
    Self *self = user_data;
    if (eel_gconf_get_boolean(MN_CONF_COMMANDS_DOUBLE_CLICKED_ENABLED))
      self_run_double_clicked_command(self);
  }

  private void
    icon_activate_run_h (MN:Mail:Icon *icon (check null type),
			 gpointer user_data (check null))
  {
    Self *self = user_data;
    self_run_double_clicked_command(self);
  }
  
  private void
    icon_activate_update_h (MN:Mail:Icon *icon (check null type),
			    gpointer user_data (check null))
  {
    Self *self = user_data;
    mn_mailboxes_check(self->mailboxes);
  }
  
  private void
    icon_activate_properties_h (MN:Mail:Icon *icon (check null type),
				gpointer user_data (check null))
  {
    mn_properties_display();
  }
  
  private void
    icon_activate_help_h (MN:Mail:Icon *icon (check null type),
			  gpointer user_data (check null))
  {
    mn_display_help(NULL);
  }
  
  private void
    icon_activate_about_h (MN:Mail:Icon *icon (check null type),
			   gpointer user_data (check null))
  {
    Self *self = user_data;
    self_display_about(self);
  }
  
  private void
    icon_activate_remove_h (MN:Mail:Icon *icon (check null type),
			    gpointer user_data (check null))
  {
    Self *self = user_data;
    g_object_unref(self);
  }

  private void
    icon_destroy_h (Gtk:Object *object (check null type),
		    gpointer user_data (check null))
  {
    Self *self = user_data;

    /* The Notification Area applet has been terminated. Recreate the icon. */
    self_init_icon(self);
  }

  private void
    run_double_clicked_command (self)
  {
    char *command;

    command = eel_gconf_get_string(MN_CONF_COMMANDS_DOUBLE_CLICKED_COMMAND);
    if (command)
      {
	GError *err = NULL;
	
	if (! g_spawn_command_line_async(command, &err))
	  {
	    mn_error_dialog(NULL,
			    _("A command error has occurred"),
			    _("Unable to execute double-clicked command: %s."),
			    err->message);
	    g_error_free(err);
	  }
	
	g_free(command);
      }
  }

  private void
    update_command (self)
  {
    char *command;

    command = eel_gconf_get_string(MN_CONF_COMMANDS_DOUBLE_CLICKED_COMMAND);
    mn_mail_icon_set_command(selfp->icon, command);
    g_free(command);
  }
  
  private void
    update_sensitivity (self)
  {
    gboolean has_manual = FALSE;
    GSList *l;
  
    MN_LIST_FOREACH(l, mn_mailboxes_get(self->mailboxes))
      {
	MNMailbox *mailbox = l->data;
	
	if (MN_MAILBOX_CAN_CHECK(mailbox) && ! mn_mailbox_get_automatic(mailbox))
	  {
	    has_manual = TRUE;
	    break;
	  }
      }

    gtk_widget_set_sensitive(selfp->icon->update_item, has_manual);
  }

  private void
    update_icon (self)
  {
    GSList *mailboxes;
    gboolean show = FALSE;
    gboolean blink = FALSE;
    GString *tooltip = NULL;

    mailboxes = mn_mailboxes_get(self->mailboxes);
    if (mailboxes)
      {
	GSList *l;
	static int old_n_new = 0;
	int n_new = 0;
	int n_error = 0;
	int n_unsupported = 0;
	GString *new_string;
	GString *error_string;
	GString *unsupported_string;

	new_string = g_string_new(NULL);
	error_string = g_string_new(NULL);
	unsupported_string = g_string_new(NULL);

	MN_LIST_FOREACH(l, mailboxes)
          {
	    MNMailbox *mailbox = l->data;
	    const char *name;
	    const char *error;

	    name = mn_mailbox_get_name(mailbox);
	    error = mn_mailbox_get_error(mailbox);
	    
	    if (mn_mailbox_get_has_new(mailbox))
	      {
		n_new++;
		if (*new_string->str)
		  g_string_append_c(new_string, '\n');
		g_string_append_printf(new_string, "    %s", name);
	      }
	    
	    if (error)
	      {
		n_error++;
		if (*error_string->str)
		  g_string_append_c(error_string, '\n');
		g_string_append_printf(error_string, "    %s (%s)", name, error);
	      }
	  
	    if (MN_IS_UNSUPPORTED_MAILBOX(mailbox))
	      {
		n_unsupported++;
		if (*unsupported_string->str)
		  g_string_append_c(unsupported_string, '\n');
		g_string_append_printf(unsupported_string, "    %s (%s)", name, mn_unsupported_mailbox_get_reason(MN_UNSUPPORTED_MAILBOX(mailbox)));
	      }
	  }

	if (n_new > 0 || n_error > 0 || n_unsupported > 0)
	  {
	    show = TRUE;
	    if (n_error > 0 || n_unsupported > 0)
	      blink = TRUE;
	  }
	
	if (n_new > 0)
	  g_string_prepend(new_string, ngettext("The following mailbox has new mail:\n",
						"The following mailboxes have new mail:\n",
						n_new));
	else
	  g_string_prepend(new_string, _("You have no new mail."));
	
	if (n_error > 0)
	  g_string_prepend(error_string, ngettext("The following mailbox reported an error:\n",
						  "The following mailboxes reported an error:\n",
						  n_error));
      
	if (n_unsupported > 0)
	  g_string_prepend(unsupported_string, ngettext("The following mailbox is unsupported:\n",
							"The following mailboxes are unsupported:\n",
							n_unsupported));
	
	tooltip = g_string_new(new_string->str);
	if (n_error > 0)
	  g_string_append_printf(tooltip, "\n\n%s", error_string->str);
	if (n_unsupported > 0)
	  g_string_append_printf(tooltip, "\n\n%s", unsupported_string->str);
	
	g_string_free(new_string, TRUE);
	g_string_free(error_string, TRUE);
	g_string_free(unsupported_string, TRUE);
	
	if (old_n_new == 0 && n_new > 0)
	  {
	    gnome_triggers_do(_("You have new mail."), NULL, "mail-notification", "new-mail", NULL);
	    if (eel_gconf_get_boolean(MN_CONF_COMMANDS_NEW_MAIL_ENABLED))
	      {
		char *command;
		
		command = eel_gconf_get_string(MN_CONF_COMMANDS_NEW_MAIL_COMMAND);
		if (command)
		  {
		    GError *err = NULL;
		    
		    if (! g_spawn_command_line_async(command, &err))
		      {
			mn_error_dialog(NULL,
					_("A command error has occurred in Mail Notification"),
					_("Unable to execute new mail command: %s."),
					err->message);
			g_error_free(err);
		      }
		    
		    g_free(command);
		  }
	      }
	  }
	old_n_new = n_new;
      }
    
    if (show)
      {
	mn_tooltips_set_tip(selfp->icon->tooltips, GTK_WIDGET(selfp->icon), tooltip->str);
	mn_blinking_image_set_blinking(MN_BLINKING_IMAGE(selfp->icon->image), blink);
	gtk_widget_show(GTK_WIDGET(selfp->icon));
      }
    else
      gtk_widget_hide(GTK_WIDGET(selfp->icon));

    if (tooltip)
      g_string_free(tooltip, TRUE);
  }

  public MNShell *
    new (void)
  {
    return MN_SHELL(GET_NEW);
  }

  public void
    display_about (self)
  {
    if (selfp->about)
      {
	gtk_window_present(GTK_WINDOW(selfp->about));
	return;
      }
    
    selfp->about = mn_about_dialog_new();
    g_object_add_weak_pointer(G_OBJECT(selfp->about), (gpointer *) &selfp->about);
    gtk_widget_show(GTK_WIDGET(selfp->about));
  }

  public void
    report (self, char **report (check null))
  {
    GString *string;
    GSList *l;

    string = g_string_new(NULL);
    MN_LIST_FOREACH(l, mn_mailboxes_get(self->mailboxes))
      {
	MNMailbox *mailbox = l->data;
	const char *uri;
	const char *error;

	uri = mn_mailbox_get_uri(mailbox);
	error = mn_mailbox_get_error(mailbox);

	g_string_append_printf(string, "%s\n", uri);

	if (mn_mailbox_get_has_new(mailbox))
	  g_string_append(string, " has-new\n");
	if (error)
	  g_string_append_printf(string, " error %s\n", error);
	if (MN_IS_UNSUPPORTED_MAILBOX(mailbox))
	  g_string_append_printf(string, " unsupported %s\n", mn_unsupported_mailbox_get_reason(MN_UNSUPPORTED_MAILBOX(mailbox)));
      }

    *report = string->str;
    g_string_free(string, FALSE);
  }
}

%h{
  extern MNShell *mn_shell;
%}
