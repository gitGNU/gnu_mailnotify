/*
 * Mail Notification
 * Copyright (C) 2003-2007 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

requires 2.0.14

%headertop{
#include <libbonobo.h>
#include "GNOME_MailNotification_Evolution.h"
%}

%h{
extern GSList *mn_evolution_glues;
%}

%{
#include <stdio.h>
#include <camel/camel-folder.h>
#include <mail/em-folder-view.h>
#include <mail/em-format.h>
#include <mail/em-message-browser.h>
#include <mail/em-utils.h>
#include <mail/mail-session.h>
#include <mail/mail-tools.h>

GSList *mn_evolution_glues = NULL;

/* see https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=208774 */
static GHashTable *folders = NULL;

typedef struct
{
  char		*uri;
  CamelFolder	*folder;
} FolderInfo;
%}

class MN:Evolution:Glue from Bonobo:Object (BonoboObject GNOME_MailNotification_Evolution_Glue)
{
  public BonoboEventSource *es;

  override (G:Object) GObject *
    constructor (GType type, unsigned int n_construct_properties, GObjectConstructParam *construct_params)
  {
    GObject *object;
    Self *self;

    object = PARENT_HANDLER(type, n_construct_properties, construct_params);
    self = SELF(object);

    self->es = bonobo_event_source_new();
    /*
     * bonobo_object_add_interface() takes ownership of the passed
     * object, that's why we must not unref es above.
     */
    bonobo_object_add_interface(BONOBO_OBJECT(self), BONOBO_OBJECT(self->es));

    mn_evolution_glues = g_slist_append(mn_evolution_glues, self);

    return object;
  }

  override (G:Object) void
    finalize (GObject *object)
  {
    mn_evolution_glues = g_slist_remove(mn_evolution_glues, object);

    PARENT_HANDLER(object);
  }

  /*
   * CORBA_string_dup() accepts a null pointer but in
   * giop_send_buffer_append_string() ORBit doesn't.
   */
  private CORBA_char *
    CORBA_string_dup_null (const CORBA_char *str)
  {
    return CORBA_string_dup(str ? str : "");
  }

  private void
    cache_folder (const char *uri (check null),
		  CamelFolder *folder (check null))
  {
    FolderInfo *info;

    info = g_new0(FolderInfo, 1);
    info->uri = g_strdup(uri);
    info->folder = folder;
    camel_object_ref(folder);

    /* uncache the folder when it is deleted */
    camel_object_hook_event(folder, "deleted", self_folder_deleted_cb, info);

    g_hash_table_replace(folders, info->uri, info);
  }

  private void
    folder_info_free (FolderInfo *info (check null))
  {
    camel_object_unhook_event(info->folder, "deleted", self_folder_deleted_cb, info);
    camel_object_unref(info->folder);
    g_free(info->uri);
    g_free(info);
  }

  private void
    folder_deleted_cb (CamelObject *object,
		       gpointer event_data,
		       gpointer user_data)
  {
    FolderInfo *info = user_data;
    gboolean status;

    status = g_hash_table_remove(folders, info->uri);
    g_assert(status == TRUE);
  }

  private CamelFolder *
    lookup_folder (const char *uri (check null), CORBA_Environment *env)
  {
    CamelFolder *folder = NULL;

    if (folders)
      {
	FolderInfo *info;

	info = g_hash_table_lookup(folders, uri);
	if (info)
	  {
	    folder = info->folder;
	    camel_object_ref(folder);
	  }
      }
    else
      folders = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, (GDestroyNotify) self_folder_info_free);

    if (! folder)
      {
	folder = mail_tool_uri_to_folder(uri, 0, NULL);
	if (folder)
	  self_cache_folder(uri, folder);
	else
	  bonobo_exception_set(env, ex_GNOME_MailNotification_Evolution_Glue_FolderNotFound);
      }

    return folder;
  }

  BonoboObject private GNOME_MailNotification_Evolution_MessageSeq *
    getUnseenMessages (PortableServer_Servant servant,
		       const CORBA_char *folder_uri,
		       CORBA_Environment *env)
  {
    CamelFolder *folder;
    GPtrArray *summary;
    int i;
    GSList *infos = NULL;
    GNOME_MailNotification_Evolution_MessageSeq *seq;

    folder = self_lookup_folder(folder_uri, env);
    if (! folder)
      return NULL;

    summary = camel_folder_get_summary(folder);

    seq = GNOME_MailNotification_Evolution_MessageSeq__alloc();
    seq->_length = 0;

    for (i = 0; i < summary->len; i++)
      {
	CamelMessageInfo *info = summary->pdata[i];

	if ((camel_message_info_flags(info) & CAMEL_MESSAGE_SEEN) == 0)
	  {
	    infos = g_slist_prepend(infos, info);
	    seq->_length++;
	  }
      }

    if (seq->_length > 0)
      {
	GSList *l;

	seq->_buffer = CORBA_sequence_GNOME_MailNotification_Evolution_Message_allocbuf(seq->_length);
	for (l = infos, i = 0; l != NULL; l = l->next, i++)
	  {
	    CamelMessageInfo *info = l->data;
	    const CamelSummaryMessageID *id;
	    char hexhash[sizeof(CamelSummaryMessageID) * 2 + 1];
	    int j;

	    id = camel_message_info_message_id(info);
	    for (j = 0; j < sizeof(id->id.hash); j++)
	      sprintf(hexhash + j * 2, "%.2x", id->id.hash[j]);

	    g_assert(camel_message_info_uid(info) != NULL);

	    seq->_buffer[i].uid = CORBA_string_dup(camel_message_info_uid(info));
	    seq->_buffer[i].sent_time = camel_message_info_date_sent(info);
	    seq->_buffer[i].received_time = camel_message_info_date_received(info);
	    seq->_buffer[i].id = CORBA_string_dup(hexhash);
	    seq->_buffer[i].from = self_CORBA_string_dup_null(camel_message_info_from(info));
	    seq->_buffer[i].subject = self_CORBA_string_dup_null(camel_message_info_subject(info));
	  }

	CORBA_sequence_set_release(seq, CORBA_TRUE);

	g_slist_free(infos);
      }

    camel_folder_free_summary(folder, summary);
    camel_object_unref(folder);

    return seq;
  }

  BonoboObject private CORBA_string
    getFolderName (PortableServer_Servant servant,
		   const CORBA_char *folder_uri,
		   CORBA_Environment *env)
  {
    CamelFolder *folder;
    CORBA_string name = NULL;

    folder = self_lookup_folder(folder_uri, env);
    if (folder)
      {
	name = self_CORBA_string_dup_null(camel_folder_get_name(folder));
	camel_object_unref(folder);
      }

    return name;
  }

  BonoboObject private void
    openMessage (PortableServer_Servant servant,
		 const CORBA_char *folder_uri,
		 const CORBA_char *message_uid,
		 CORBA_Environment *env)
  {
    CamelFolder *folder;
    GtkWidget *browser;

    folder = self_lookup_folder(folder_uri, env);
    if (! folder)
      return;

    /* modelled after Evolution's handleuri_got_folder() */

    browser = em_message_browser_window_new();

    em_format_set_session((EMFormat *) ((EMFolderView *) browser)->preview, session);
    em_folder_view_set_folder((EMFolderView *) browser, folder, folder_uri);
    em_folder_view_set_message((EMFolderView *) browser, message_uid, FALSE);
    gtk_widget_show(((EMMessageBrowser *) browser)->window);

    camel_object_unref(folder);
  }

  BonoboObject private void
    setMessageFlags (PortableServer_Servant servant,
		     const CORBA_char *folder_uri,
		     const CORBA_char *message_uid,
		     CORBA_unsigned_long flags,
		     CORBA_Environment *env)
  {
    CamelFolder *folder;

    folder = self_lookup_folder(folder_uri, env);
    if (! folder)
      return;

    if (! camel_folder_set_message_flags(folder, message_uid, flags, flags))
      bonobo_exception_set(env, ex_GNOME_MailNotification_Evolution_Glue_MessageNotFound);

    camel_object_unref(folder);
  }

  public BonoboObject *
    factory_cb (BonoboGenericFactory *factory,
		const char *iid,
		gpointer closure)
  {
    return BONOBO_OBJECT(GET_NEW);
  }

  public void
    global_cleanup (void)
  {
    g_slist_foreach(mn_evolution_glues, (GFunc) bonobo_object_unref, NULL);
    g_slist_free(mn_evolution_glues);
    mn_evolution_glues = NULL;

    g_hash_table_destroy(folders);
    folders = NULL;
  }
}
