/* 
 * Copyright (c) 2004 Jean-Yves Lefort <jylefort@brutele.be>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

requires 2.0.10

%headertop{
#include "mn-mailbox.h"
%}

%privateheader{
#include "mn-soup.h"
%}

%{
#include "config.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <glib/gi18n-lib.h>
#include "mn-mailbox-private.h"
#include "mn-util.h"
#include "mn-stock.h"
#include "mn-sgml-ref.h"

#define MESSAGE_IS_ERROR(message) \
  (! SOUP_STATUS_IS_SUCCESSFUL((message)->status_code))
%}

class MN:Gmail:Mailbox from MN:Mailbox
{
  private SoupSession *session;
  private GHashTable *cookies destroywith g_hash_table_destroy;
  private gboolean logged_in;

  class_init (class)
  {
    MN_MAILBOX_CLASS(class)->stock_id = MN_STOCK_GMAIL;
    MN_MAILBOX_CLASS(class)->format = "Gmail";
  }

  override (G:Object) GObject *
    constructor (GType type, guint n_construct_properties, GObjectConstructParam *construct_params)
  {
    GObject *object;

    object = PARENT_HANDLER(type, n_construct_properties, construct_params);
    
    if (! soup_ssl_supported)
      mn_mailbox_set_init_error(MN_MAILBOX(object), _("libsoup has not been compiled with SSL/TLS support"));

    return object;
  }

  override (MN:Mailbox) gboolean
    impl_is (MNMailbox *dummy, MN:URI *uri (check null type))
  {
    return MN_URI_IS_GMAIL(uri);
  }

  override (MN:Mailbox) void
    impl_check (MN:Mailbox *mailbox (check null type))
  {
    Self *self = SELF(mailbox);

    selfp->session = mn_soup_session_new();
    if (selfp->logged_in)
      self_check_internal(self);
    else
      self_login(self);
  }
  
  private void
    end_check (self)
  {
    g_object_unref(selfp->session);
    mn_mailbox_end_check(MN_MAILBOX(self));
  }
  
  private gboolean
    get (self,
	 const char *uri_string (check null),
	 SoupMessageCallbackFn callback (check null))
  {
    SoupMessage *message;

    message = soup_message_new(SOUP_METHOD_GET, uri_string);
    if (message)
      {
	self_get_from_message(self, soup_message_new(SOUP_METHOD_GET, uri_string), callback);
	return TRUE;
      }
    else
      {
	mn_mailbox_notice(MN_MAILBOX(self), _("unable to parse URI \"%s\""), uri_string);
	return FALSE;
      }
  }
  
  private void
    get_from_uri (self,
		  SoupUri *uri (check null),
		  SoupMessageCallbackFn callback (check null))
  {
    self_get_from_message(self, soup_message_new_from_uri(SOUP_METHOD_GET, uri), callback);
  }
  
  private void
    get_from_message (self,
		      Soup:Message *message (check null type),
		      SoupMessageCallbackFn callback (check null))
  {
    char *cookie;

    soup_message_add_header(message->request_headers, "User-Agent", "Mail Notification");

    cookie = self_build_cookie(self);
    if (cookie)
      {
	soup_message_add_header(message->request_headers, "Cookie", cookie);
	g_free(cookie);
      }
    
    self_dump_request(self, message);
    soup_session_queue_message(selfp->session, message, callback, self);
    /* message will be unreffed by libsoup after invoking the callback */
  }
  
  private void
    dump_request (self, Soup:Message *message (check null type))
  {
    const SoupUri *suri;
    char *uri;

    suri = soup_message_get_uri(message);
    uri = soup_uri_to_string(suri, FALSE);
    mn_mailbox_notice(MN_MAILBOX(self), "> GET %s", uri);
    g_free(uri);

    soup_message_foreach_header(message->request_headers, self_dump_request_cb, self);
  }

  private void
    dump_request_cb (gpointer key (check null),
		     gpointer value (check null),
		     gpointer user_data (check null))
  {
    Self *self = user_data;
    const char *header_name = key;
    const char *header_value = value;

    mn_mailbox_notice(MN_MAILBOX(self), "> %s: %s", header_name, header_value);
  }
  
  private void
    dump_response (self, Soup:Message *message (check null type))
  {
    char *body;
    char **lines;
    int i;
    
    soup_message_foreach_header(message->response_headers, self_dump_response_cb, self);

    body = g_strndup(message->response.body, message->response.length);
    lines = g_strsplit(body, "\n", 0);
    g_free(body);

    for (i = 0; lines[i]; i++)
      mn_mailbox_notice(MN_MAILBOX(self), "< %s", lines[i]);
    g_strfreev(lines);
  }

  private void
    dump_response_cb (gpointer key (check null),
		      gpointer value (check null),
		      gpointer user_data (check null))
  {
    Self *self = user_data;
    const char *header_name = key;
    const char *header_value = value;

    mn_mailbox_notice(MN_MAILBOX(self), "< %s: %s", header_name, header_value);
  }

  /**
   * get_token:
   * @str: the string to search
   * @pre: the start of the token
   * @post: the end of the token
   * @include_pre: whether to include @pre in the result or not
   * @include_post: whether to include @post in the result or not
   *
   * Gets the first token of @str included between @pre and @post.
   *
   * Return value: a newly allocated string containing the token or
   *               %NULL if not found.
   **/
  private char *
    get_token (const char *str (check null),
	       const char *pre (check null),
	       const char *post (check null),
	       gboolean include_pre,
	       gboolean include_post)
  {
    char *token = NULL;
    char *pre_loc;
    
    pre_loc = strstr(str, pre);
    if (pre_loc)
      {
	char *after_pre_loc;
	char *post_loc;
	
	after_pre_loc = pre_loc + strlen(pre);
	post_loc = strstr(after_pre_loc, post);
	if (post_loc)
	  {
	    char *start = include_pre ? pre_loc : after_pre_loc;
	    char *end = include_post ? post_loc + strlen(post) : post_loc;
	    
	    token = g_strndup(start, end - start);
	  }
      }
    
    return token;
  }

  private void
    login (self)
  {
    char *uri;
    char *escaped_username;
    char *escaped_password;
    gboolean status;

    g_return_if_fail(selfp->logged_in == FALSE);

    if (selfp->cookies)
      g_hash_table_destroy(selfp->cookies);
    selfp->cookies = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
	
    mn_mailbox_notice(MN_MAILBOX(self), _("logging in"));

#define EXTRA_CHARS ";/?:@&=+$,"/* taken from RFC 2396 2.2 */
    escaped_username = soup_uri_encode(MN_MAILBOX(self)->uri->username, EXTRA_CHARS);
    escaped_password = soup_uri_encode(MN_MAILBOX(self)->uri->password, EXTRA_CHARS);
    uri = g_strdup_printf("https://www.google.com/accounts/ServiceLoginBoxAuth?service=mail&continue=http://gmail.google.com/gmail&Email=%s&Passwd=%s", escaped_username, escaped_password);
    g_free(escaped_username);
    g_free(escaped_password);

    status = self_get(self, uri, self_login_cb1);
    g_free(uri);

    if (! status)
      {
	mn_mailbox_set_error(MN_MAILBOX(self), _("login failed"));
	self_end_check(self);
      }
  }
  
  private void
    login_cb1 (Soup:Message *message (check null type),
	       gpointer user_data (check null))
  {
    Self *self = user_data;

    if (MESSAGE_IS_ERROR(message))
      mn_mailbox_set_error(MN_MAILBOX(self), _("unable to transfer data: %s"), message->reason_phrase);
    else
      {
	char *body;
	char *next_location;

	self_dump_response(self, message);
	self_update_cookies(self, message);

	body = g_strndup(message->response.body, message->response.length);
 	next_location = self_get_token(body, "top.location = \"", "\"", FALSE, FALSE);
	g_free(body);

	if (next_location)
	  {
	    char *query;	/* pointer into next_location */
	    char *uri;
	    SoupUri *suri;
	    gboolean status;

	    /*
	     * The following kludges work around http://bugzilla.ximian.com/show_bug.cgi?id=66516.
	     * FIXME: remove it and bump libsoup version requirement
	     * when the bug is fixed.
	     */

	    query = strchr(next_location, '?');
	    if (query)
	      *query = 0;

	    uri = g_strdup_printf("https://www.google.com/accounts/%s", next_location);
	    suri = soup_uri_new(uri);

	    if (suri)
	      {
		if (query)
		  {
		    suri->query = g_strdup(query + 1);
		    suri->broken_encoding = TRUE;
		  }

		self_get_from_uri(self, suri, self_login_cb2);
		soup_uri_free(suri);
		
		status = TRUE;
	      }
	    else
	      {
		mn_mailbox_notice(MN_MAILBOX(self), _("unable to parse URI \"%s\""), uri);
		status = FALSE;
	      }

	    g_free(uri);
	    g_free(next_location);
	    
	    if (status)
	      return;
	  }

	mn_mailbox_set_error(MN_MAILBOX(self), _("login failed"));
      }
    
    /* if this point is reached, an error occurred */
    self_end_check(self);
  }
  
  private void
    login_cb2 (Soup:Message *message (check null type),
	       gpointer user_data (check null))
  {
    Self *self = user_data;

    if (MESSAGE_IS_ERROR(message))
      mn_mailbox_set_error(MN_MAILBOX(self), _("unable to transfer data: %s"), message->reason_phrase);
    else
      {
	char *body;
	char *next_location;

	self_dump_response(self, message);
	self_update_cookies(self, message);
	
	body = g_strndup(message->response.body, message->response.length);
	next_location = self_get_token(body, "location.replace(\"", "\")", FALSE, FALSE);
	g_free(body);

	if (next_location)
	  {
	    gboolean status;

	    status = self_get(self, next_location, self_login_cb3);
	    g_free(next_location);

	    if (status)
	      return;
	  }

	mn_mailbox_set_error(MN_MAILBOX(self), _("login failed"));
      }

    /* if this point is reached, an error occurred */
    self_end_check(self);
  }
  
  private void
    login_cb3 (Soup:Message *message (check null type),
	       gpointer user_data (check null))
  {
    Self *self = user_data;

    if (MESSAGE_IS_ERROR(message))
      mn_mailbox_set_error(MN_MAILBOX(self), _("unable to transfer data: %s"), message->reason_phrase);
    else
      {
	char *body;
	char *token;

	self_dump_response(self, message);
	self_update_cookies(self, message);

	body = g_strndup(message->response.body, message->response.length);
	token = strstr(body, "frame name=js src=/gmail");
	
	if (token)
	  {
	    selfp->logged_in = TRUE;
	    mn_mailbox_notice(MN_MAILBOX(self), _("successfully logged in"));
	    self_check_internal(self);
	    
	    return;
	  }

	mn_mailbox_set_error(MN_MAILBOX(self), _("login failed"));
      }

    /* if this point is reached, an error occurred */
    self_end_check(self);
  }

  private void
    update_cookies (self, Soup:Message *message (check null type))
  {
    const GSList *set_cookie_headers;
    const GSList *l;
    
    set_cookie_headers = soup_message_get_header_list(message->response_headers, "Set-Cookie");
    MN_LIST_FOREACH(l, set_cookie_headers)
      {
	const char *value = l->data;
	char *equal;

	equal = strchr(value, '=');
	if (equal && equal - value > 0)
	  {
	    char *end;
	    char *cookie_name;
	    char *cookie_value;

	    end = strchr(equal, ';');

	    cookie_name = g_strndup(value, equal - value);
	    cookie_value = end
	      ? g_strndup(equal + 1, end - equal - 1)
	      : g_strdup(equal + 1);

	    g_hash_table_insert(selfp->cookies, cookie_name, cookie_value);
	  }
      }
  }

  private char *
    build_cookie (self)
  {
    GString *cookie;
    char *str;

    cookie = g_string_new(NULL);
    g_hash_table_foreach(selfp->cookies, self_build_cookie_cb, cookie);

    if (*cookie->str)
      str = g_string_free(cookie, FALSE);
    else
      {
	str = NULL;
	g_string_free(cookie, TRUE);
      }

    return str;
  }

  private void
    build_cookie_cb (gpointer key, gpointer value, gpointer user_data)
  {
    GString *cookie = user_data;

    if (*cookie->str)
      g_string_append(cookie, "; ");

    g_string_append_printf(cookie, "%s=%s", (const char *) key, (const char *) value);
  }
  
  private void
    check_internal (self)
  {
    mn_mailbox_notice(MN_MAILBOX(self), _("searching for unread mail"));

    if (! self_get(self, "https://gmail.google.com/gmail?search=adv&as_subset=unread&view=tl&start=0", self_check_internal_cb))
      {
	mn_mailbox_set_error(MN_MAILBOX(self), _("unable to search for unread mail"));
	self_end_check(self);
      }
  }

  private void
    check_internal_cb (Soup:Message *message (check null type),
		       gpointer user_data)
  {
    Self *self = user_data;

    if (MESSAGE_IS_ERROR(message))
      mn_mailbox_set_error(MN_MAILBOX(self), _("unable to transfer data: %s"), message->reason_phrase);
    else
      {
	self_dump_response(self, message);
	self_parse_unread(self, message);
      }

    self_end_check(self);
  }

  private void
    parse_unread (self, Soup:Message *message (check null type))
  {
    MNMailbox *mailbox = MN_MAILBOX(self);
    int count = -1;
    GSList *messages = NULL;
    char *body;
    char *results;
  
    body = g_strndup(message->response.body, message->response.length);

    results = strstr(body, "Search results for: is:unread\",\"");
    if (results)
      {
	char *count_str;
	
	count_str = self_get_token(results + 32, ",", ",", FALSE, FALSE);
	if (count_str)
	  {
	    if (mn_str_isnumeric(count_str))
	      count = atoi(count_str);
	    g_free(count_str);
	  }
      }

    if (count != -1)
      {
	char *p = results + 32;

	while (p && (p = strstr(p, ",1,0")))
	  {
	    char *date;
	    char *sender_email;
	    char *sender_name;
	    char *subject;

	    time_t sent_time = 0;
	    char *from = NULL;
	    char *expanded_subject = NULL;
	    
	    date = self_get_token(p, "\\<b\\>", "\\</b\\>", FALSE, FALSE);
	    sender_email = self_get_token(p, "<span id=\\'_user_", "\\'", FALSE, FALSE);
	    sender_name = self_get_token(p, "\\'\\>\\<b\\>", "\\</b\\>", FALSE, FALSE);
	    subject = self_get_token(p, ";\",\"\\<b\\>", "\\</b\\>", FALSE, FALSE);

	    if (date)
	      {
		sent_time = self_parse_date(date);
		g_free(date);
	      }
		
	    if (sender_name && sender_email)
	      {
		char *tmp;

		tmp = g_strdup_printf("%s <%s>", sender_name, sender_email);
		from = mn_sgml_ref_expand(tmp);
		g_free(tmp);
	      }
	    else if (sender_name)
	      from = mn_sgml_ref_expand(sender_name);
	    else if (sender_email)
	      from = mn_sgml_ref_expand(sender_email);

	    g_free(sender_email);
	    g_free(sender_name);

	    if (subject)
	      {
		if (strcmp(subject, "(no subject)"))
		  expanded_subject = mn_sgml_ref_expand(subject);
		g_free(subject);
	      }
	    
	    messages = g_slist_append(messages, mn_message_new(mailbox->uri,
							       NULL,
							       sent_time,
							       NULL,
							       from,
							       expanded_subject));

	    g_free(from);
	    g_free(expanded_subject);

	    p = strstr(p, "[\"^i\"]");
	  }
      }

    g_free(body);

    if (count == -1)
      mn_mailbox_set_error(mailbox, _("unable to parse Gmail data"));
    else
      {
	mn_mailbox_set_has_new(mailbox, count != 0);
	mn_mailbox_set_messages(mailbox, messages);
      }

    mn_g_object_slist_free(messages);
  }

  private time_t
    parse_date (const char *date (check null))
  {
    time_t t = 0;
#ifdef HAVE_TIMEGM
    time_t now;

    now = mn_time();
    if (now > 0)
      {
	int hours;
	int minutes;
	char ampm[3];
	char month_str[4];
	int day;
	struct tm *tm = NULL;
	
	/* convert now to UTC-7 (Gmail time) */
	now -= (7 * 3600);
	
	if (sscanf(date, "%d:%d%2s", &hours, &minutes, ampm) == 3)
	  {
	    tm = gmtime(&now);
	    tm->tm_hour = hours;
	    if (ampm[0] == 'p')
	      tm->tm_hour += 12;
	    tm->tm_min = minutes;
	    tm->tm_sec = 0;
	  }
	else if (sscanf(date, "%3s %d", month_str, &day) == 2)
	  {
	    const char *months[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
	    int i;
	    
	    for (i = 0; i < G_N_ELEMENTS(months); i++)
	      if (! strcmp(month_str, months[i]))
		{
		  tm = gmtime(&now);
		  tm->tm_mon = i;
		  tm->tm_mday = day;
		  tm->tm_hour = 0;
		  tm->tm_min = 0;
		  tm->tm_sec = 0;
		  
		  break;
		}
	  }

	if (tm)
	  t = timegm(tm) + (7 * 3600); /* add 7 hours, because Gmail time is UTC-7 */
      }
#endif /* HAVE_TIMEGM */

    return t;
  }
}
